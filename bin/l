#!/usr/bin/env ruby

## Jxck's own ls alternatives

require 'etc'

class Node
  attr_reader :name, :stat
  def initialize(entry, opts)
    @name = entry
    @stat = File.lstat(entry)
    @all = opts["a"]
    @human = opts["h"]
  end

  def uid
    Etc.getpwuid(@stat.uid).name
  end

  def gid
    Etc.getgrgid(@stat.gid).name
  end

  def dir?
    @stat.directory?
  end

  def file?
    @stat.file?
  end

  def exec?
    @stat.executable_real?
  end

  def sym?
    @stat.symlink?
  end

  def pipe?
    @stat.pipe?
  end

  def socket?
    @stat.socket?
  end

  def block?
    @stat.blockdev?
  end

  def char?
    @stat.chardev?
  end

  def mode
    mode = @stat.mode

    str = ""

    # user
    str << ((mode & Integer("0b100000000") > 0) ? "r" : "-")
    str << ((mode & Integer("0b010000000") > 0) ? "w" : "-")
    str << ((mode & Integer("0b001000000") > 0) ? "x" : "-")

    # group
    str << ((mode & Integer("0b000100000") > 0) ? "r" : "-")
    str << ((mode & Integer("0b000010000") > 0) ? "w" : "-")
    str << ((mode & Integer("0b000001000") > 0) ? "x" : "-")

    # other
    str << ((mode & Integer("0b000000100") > 0) ? "r" : "-")
    str << ((mode & Integer("0b000000010") > 0) ? "w" : "-")
    str << ((mode & Integer("0b000000001") > 0) ? "x" : "-")

    str
  end

  def size
    size = @stat.size
    if size > 1024*1024
      size = size.quo(1024*1024).round(1).to_f.to_s + "M"
    elsif size > 1024
      size = size.quo(1024).round(1).to_f.to_s + "K"
    else
      size = size.to_s + "B"
    end
    size.rjust(6)
  end

  def mtime
    @stat.mtime.strftime("%Y-%m-%d %H:%M")
  end

  def color(name, str)
    colors = {
      :BLACK  => "0;30",
      :RED    => "0;31",
      :GREEN  => "0;32",
      :BROWN  => "0;33",
      :NAVY   => "0;34",
      :PURPLE => "0;35",
      :CYAN   => "0;36",
      :GRAY   => "0;37",
      :DIM    => "1;30",
      :ORANGE => "1;31",
      :LIME   => "1;32",
      :YELLOW => "1;33",
      :BLUE   => "1;34",
      :PINK   => "1;35",
      :AQUA   => "1;36",
      :WHITE  => "1;37",
    }
    code = colors[name]
    return  "\x1b[#{code}m#{str}\x1b[0m"
  end

  def to_s
    name = File.basename(@name)
    if dir?
      name = color(:NAVY, name)
    elsif sym?
      name = color(:CYAN, name)
      path = File.readlink(@name)
      name = "#{name} -> #{path}"
    elsif exec?
      name = color(:RED, name)
    elsif pipe?
      name = color(:ORANGE, name)
    elsif socket?
      name = color(:YELLOW, name)
    elsif block?
      name = color(:PINK, name)
    elsif char?
      name = color(:AQUA, name)
    end

    if !@all
      return name.to_s
    end

    size = @human ? self.size: @stat.size.to_s.rjust(10)

    [
      mode,
      uid,
      gid,
      size,
      mtime,
      name
    ].join(" ")
  end

  def level
    return 1 if dir?
    return 2 if pipe?
    return 3 if socket?
    return 4 if block?
    return 5 if char?
    return 6 if sym?
    return 7 if exec?
    return 8 if file?
  end

  def <=>(target)
    if level == target.level
      return name <=> target.name
    end

    level <=> target.level
  end
end

require "pathname"
require "optparse"

opts = ARGV.getopts('ah')
target = ARGV[0] || "."

path = Pathname.new(target)

result = Dir.entries(target).reject {|entry|
  entry == "." || entry == ".."
}.map {|entry|
  Node.new(path.join(entry), opts)
}.sort

puts result
