#!/usr/bin/env ruby

HELP=<<EOS
simplest http server shows current directory
- default port: 3000
- default key : /keys/key.pem
- default crt : /keys/cert.pem
- export text formats as text/plain (md, log, json etc)
- returns default favicon: $DOTFILES/misc/favicon.ico

$ https
$ https 4000 ./key.pem ./cert.pem
EOS

require "webrick"
require "webrick/https"
require "json"

if ARGV.include?('-h')
  puts HELP
  exit(0)
end

port = ARGV.shift || 3000
key  = ARGV.shift || "/keys/key.pem"
cert = ARGV.shift || "/keys/cert.pem"

# http://svn.ruby-lang.org/cgi-bin/viewvc.cgi/trunk/lib/webrick/httputils.rb?view=markup
mime = WEBrick::HTTPUtils::DefaultMimeTypes.merge({
  "js"       => "text/javascript",
  "json"     => "text/json",
  "log"      => "text/plain",
  "md"       => "text/plain",
  "markdown" => "text/plain",
  "webp"     => "image/webp",
})

config = {
  :Port            => port,
  :DocumentRoot    => ".",
  :MimeTypes       => mime,
  :SSLEnable       => true,
  :SSLCertificate  => OpenSSL::X509::Certificate.new(File.open(cert).read),
  :SSLPrivateKey   => OpenSSL::PKey::RSA.new(File.open(key).read),
  :StartCallback   => lambda {
    puts `ip`
  },
  :RequestCallback => lambda {|req, res|
    res.header.merge!({
      "Access-Control-Allow-Methods" => "GET, PUT, POST, DELETE, HEAD, OPTIONS",
      "Access-Control-Allow-Origin" => "*",
      "Access-Control-Allow-Credentials" => "true",
      "Access-Control-Allow-Headres" => "Accept, Accept-Encoding, Accept-Language, Cookie, Referer, User-Agent",
      "Service-Worker-Allowed" => "/",
    })
  }

  # auto generate self signed cert file
  # :SSLCertName => [["CN", "devserver"]],
}

server = WEBrick::HTTPServer.new(config)

# /favicon.ico
server.mount("/favicon.ico", WEBrick::HTTPServlet::FileHandler, "#{__dir__}/../misc/favicon.ico")

# /random
server.mount_proc('/random') do |req, res|
  @i ||= 0
  sleep(2)
  seq = (@i+=1).to_s
  now = Time.now.to_s
  random = (0...8).map{ ('A'..'Z').to_a[rand(26)] }.join

  res.header.merge!({
    "Content-Type" => "text/json",
    "X-Seq" => seq
  })
  res.body = JSON.pretty_generate({
    seq: seq,
    now: now,
    random: random
  })
end

# /upload
class Uploader < WEBrick::HTTPServlet::AbstractServlet
  def do_POST(req, res)
    filename = req.query['upload'].filename
    uploadedFile = File.open(filename, "wb")
    uploadedFile.write req.query['upload'].to_s
    uploadedFile.close
    res.set_redirect(WEBrick::HTTPStatus::SeeOther, '/')
  end

  def do_GET(req, res)
    res.content_type = "text/html"
    res.body = <<-EOS
      <form method=POST action=/upload enctype=multipart/form-data>
          <input type=file name=upload />
          <input type=submit value=upload />
      </form>
    EOS
  end
end
server.mount('/upload', Uploader)

# /login
class Login < WEBrick::HTTPServlet::AbstractServlet
  def do_POST(req, res)
    username = req.query['username']
    password = req.query['password']
    cookie = WEBrick::Cookie.new("session_id", "1q2w3e4r5t6y7u8i9o0p")
    res["Set-Cookie"] = cookie.to_s
    res.content_type = "text/html"
    res.body = <<-EOS
      <h1>Login Success</h1>
      <p>hello #{username} !</p>
    EOS
  end

  def do_GET(req, res)
    res.content_type = "text/html"
    res.body = <<-EOS
      <style>
        form {
          width: 15em;
          padding: 1em;
        }
        label {
        }
        div {
          margin: 1em 0 0 0;
        }
        button {
          width: 4em;
          float: right;
          margin-right: 0;
        }
      </style>
      <form method=POST action=/login>
        <fieldset>
          <legend>login</legend>
          <div>
            <label for=username>username:</label>
            <input id=username type=text name=username />
          </div>
          <div>
            <label for=password>password:</label>
            <input id=password type=password name=password />
          </div>
          <div>
            <button type=submit>ok</button>
          </div>
        </fieldset>
      </form>
    EOS
  end
end
server.mount('/login', Login)


Signal.trap("INT") { server.shutdown }
server.start
