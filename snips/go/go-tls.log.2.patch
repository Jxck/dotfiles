diff --git cipher_suites.go cipher_suites.go
index a5fed29..cad4b98 100644
--- cipher_suites.go
+++ cipher_suites.go
@@ -15,10 +15,12 @@ import (
 	"hash"
 )
 
+// keyAgreement の生成(generate) と処理(process)実装
 // a keyAgreement implements the client and server side of a TLS key agreement
 // protocol by generating and processing key exchange messages.
 type keyAgreement interface {
 	// On the server side, the first two methods are called in order.
+	// Server では、以下二つが順番に呼ばれる
 
 	// In the case that the key agreement protocol doesn't use a
 	// ServerKeyExchange message, generateServerKeyExchange can return nil,
@@ -27,6 +29,7 @@ type keyAgreement interface {
 	processClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)
 
 	// On the client side, the next two methods are called in order.
+	// Client では、以下二つが順番に呼ばれる
 
 	// This method may not be called if the server doesn't send a
 	// ServerKeyExchange message.
@@ -34,6 +37,7 @@ type keyAgreement interface {
 	generateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)
 }
 
+// 暗号スイートがそれぞれを含むかどうか
 const (
 	// suiteECDH indicates that the cipher suite involves elliptic curve
 	// Diffie-Hellman. This means that it should only be selected when the
@@ -56,6 +60,7 @@ const (
 	suiteDefaultOff
 )
 
+// key agreement と cipher, MAC 関数の組
 // A cipherSuite is a specific combination of key agreement, cipher and MAC
 // function. All cipher suites currently assume RSA key agreement.
 type cipherSuite struct {
diff --git common.go common.go
index a3d75d6..c76ffe4 100644
--- common.go
+++ common.go
@@ -13,6 +13,7 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 	"math/big"
 	"strings"
 	"sync"
@@ -472,6 +473,7 @@ func (c *Config) maxVersion() uint16 {
 	return c.MaxVersion
 }
 
+// secp256r1(23), secp384r1(24), secp521r1(25)
 var defaultCurvePreferences = []CurveID{CurveP256, CurveP384, CurveP521}
 
 func (c *Config) curvePreferences() []CurveID {
@@ -496,9 +498,19 @@ func (c *Config) mutualVersion(vers uint16) (uint16, bool) {
 	return vers, true
 }
 
+// ClientHello を元に最適な証明書を返す。が普通は一つなので最初のを返す。
 // getCertificate returns the best certificate for the given ClientHelloInfo,
 // defaulting to the first element of c.Certificates.
 func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error) {
+	log.Printf(i.i() + ">Config.getCertificate()")
+	defer func() { log.Printf(i.o() + "<Config.getCertificate()") }()
+
+	log.Printf(i.c()+"%#v...%#v", clientHello.CipherSuites[:4], clientHello.CipherSuites[len(clientHello.CipherSuites)-4:])
+	log.Printf(i.c()+"%#v", clientHello.ServerName)
+	log.Printf(i.c()+"%#v", clientHello.SupportedCurves)
+	log.Printf(i.c()+"%#v", clientHello.SupportedPoints)
+
+	// SNI が有効だった場合
 	if c.GetCertificate != nil &&
 		(len(c.Certificates) == 0 || len(clientHello.ServerName) > 0) {
 		cert, err := c.GetCertificate(clientHello)
@@ -507,10 +519,12 @@ func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, err
 		}
 	}
 
+	// 証明書が無い場合
 	if len(c.Certificates) == 0 {
 		return nil, errors.New("crypto/tls: no certificates configured")
 	}
 
+	// 一個しかない
 	if len(c.Certificates) == 1 || c.NameToCertificate == nil {
 		// There's only one choice, so no point doing any work.
 		return &c.Certificates[0], nil
diff --git connection.go connection.go
index e3dcf15..c05488c 100644
--- connection.go
+++ connection.go
@@ -14,11 +14,46 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 	"net"
+	"strings"
 	"sync"
 	"time"
 )
 
+type Ind struct {
+	indent int
+}
+
+func (i *Ind) i() (str string) {
+	str = "\t" + strings.Repeat(" ", i.indent)
+	i.indent = i.indent + 1
+	return
+}
+
+func (i *Ind) c() string {
+	return "\t" + strings.Repeat(" ", i.indent)
+}
+
+func (i *Ind) o() (str string) {
+	i.indent = i.indent - 1
+	str = "\t" + strings.Repeat(" ", i.indent)
+	return
+}
+
+var i = new(Ind)
+
+var S = map[recordType]string{
+	0x14: "CHANGE_CIPHER_SPEC",
+	0x15: "ALERT",
+	0x16: "HANDSHAKE",
+	0x17: "APPLICATION_DATA",
+}
+
+func init() {
+	log.SetFlags(log.Lshortfile)
+}
+
 // A Conn represents a secured connection.
 // It implements the net.Conn interface.
 type Conn struct {
@@ -127,6 +162,9 @@ func (hc *halfConn) error() error {
 // prepareCipherSpec sets the encryption and MAC states
 // that a subsequent changeCipherSpec will use.
 func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) {
+	log.Println(i.i(), ">halfConn.prepareCipherSpec")
+	defer func() { log.Println(i.o(), "<halfConn.prepareCipherSpec") }()
+
 	hc.version = version
 	hc.nextCipher = cipher
 	hc.nextMac = mac
@@ -135,6 +173,9 @@ func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac ma
 // changeCipherSpec changes the encryption and MAC states
 // to the ones previously passed to prepareCipherSpec.
 func (hc *halfConn) changeCipherSpec() error {
+	log.Println(i.i(), ">halfConn.changeCipherSpec")
+	defer func() { log.Println(i.o(), "<halfConn.changeCipherSpec") }()
+
 	if hc.nextCipher == nil {
 		return alertInternalError
 	}
@@ -238,23 +279,32 @@ type cbcMode interface {
 // success boolean, the number of bytes to skip from the start of the record in
 // order to get the application payload, and an optional alert value.
 func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert) {
+	log.Println(i.i() + ">halfConn.decrypt()")
+	defer func() { log.Println(i.o() + "<halfConn.decrypt()") }()
+
+	// レコードから body だけ取り出す
 	// pull out payload
 	payload := b.data[recordHeaderLen:]
 
 	macSize := 0
 	if hc.mac != nil {
+		log.Println(i.c() + "hc has mac")
 		macSize = hc.mac.Size()
 	}
 
 	paddingGood := byte(255)
 	explicitIVLen := 0
 
+	// cipher があったら複合化
 	// decrypt
 	if hc.cipher != nil {
+		log.Printf(i.c()+"hc has cipher %T", hc.cipher)
 		switch c := hc.cipher.(type) {
 		case cipher.Stream:
+			log.Println(i.c() + "cipher.Stream")
 			c.XORKeyStream(payload, payload)
 		case cipher.AEAD:
+			log.Println(i.c() + "cipher.AEAD")
 			explicitIVLen = 8
 			if len(payload) < explicitIVLen {
 				return false, 0, alertBadRecordMAC
@@ -269,12 +319,17 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)
 			additionalData[11] = byte(n >> 8)
 			additionalData[12] = byte(n)
 			var err error
+
+			log.Printf(i.c()+"before: %#v", payload)
 			payload, err = c.Open(payload[:0], nonce, payload, additionalData[:])
 			if err != nil {
 				return false, 0, alertBadRecordMAC
 			}
+			log.Printf(i.c()+"after: %#v", payload)
+
 			b.resize(recordHeaderLen + explicitIVLen + len(payload))
 		case cbcMode:
+			log.Println(i.c() + "cbcMode")
 			blockSize := c.BlockSize()
 			if hc.version >= VersionTLS11 {
 				explicitIVLen = blockSize
@@ -313,6 +368,7 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)
 
 	// check, strip mac
 	if hc.mac != nil {
+		log.Printf(i.c()+"hc has mac %v", hc.mac)
 		if len(payload) < macSize {
 			return false, 0, alertBadRecordMAC
 		}
@@ -444,17 +500,28 @@ func (b *block) reserve(n int) {
 // readFromUntil reads from r into b until b contains at least n bytes
 // or else returns an error.
 func (b *block) readFromUntil(r io.Reader, n int) error {
+	log.Printf(i.i()+">block.readFromUntil(r, n=%v), len(b.data)=%v cap(b.data)=%v", n, len(b.data), cap(b.data))
+	defer func() { log.Printf(i.o() + "<block.readFromUntil") }()
+
 	// quick case
+	// n byte 読みたいところすでに読まれてる
 	if len(b.data) >= n {
 		return nil
 	}
 
 	// read until have enough.
+	// b.data がバッファでそこに cap を確保する
 	b.reserve(n)
 	for {
+		// conn.Read()
+		// 確保したバッファのデータ末尾から cap までの間に
+		// 読めるだけ read() する。
 		m, err := r.Read(b.data[len(b.data):cap(b.data)])
+		log.Printf(i.c()+"%v byte read", m)
+		// len が更新されて無いので、読んだ分で更新
 		b.data = b.data[0 : len(b.data)+m]
 		if len(b.data) >= n {
+			log.Println(i.c()+"len(b.data) >= n", len(b.data), n)
 			// TODO(bradfitz,agl): slightly suspicious
 			// that we're throwing away r.Read's err here.
 			break
@@ -511,6 +578,9 @@ func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) {
 // and updates the record layer state.
 // c.in.Mutex <= L; c.input == nil.
 func (c *Conn) readRecord(want recordType) error {
+	log.Println(i.i()+">conn.readRecord()", S[want])
+	defer func() { log.Println(i.o()+"<conn.readRecord()", want) }()
+
 	// Caller must be in sync with connection:
 	// handshake data if handshake not yet completed,
 	// else application data.  (We don't support renegotiation.)
@@ -537,6 +607,7 @@ Again:
 	b := c.rawInput
 
 	// Read header, payload.
+	// d.data に少なくとも record header 分は読み込む
 	if err := b.readFromUntil(c.conn, recordHeaderLen); err != nil {
 		// RFC suggests that EOF without an alertCloseNotify is
 		// an error, but popular web sites seem to do this,
@@ -550,6 +621,7 @@ Again:
 		return err
 	}
 	typ := recordType(b.data[0])
+	log.Printf(i.c()+"typ: %#v", S[typ])
 
 	// No valid TLS record has a type of 0x80, however SSLv2 handshakes
 	// start with a uint16 length where the MSB is set and the first record
@@ -561,7 +633,10 @@ Again:
 	}
 
 	vers := uint16(b.data[1])<<8 | uint16(b.data[2])
+	log.Printf(i.c()+"vers: %#v", vers)
+
 	n := int(b.data[3])<<8 | int(b.data[4])
+	log.Printf(i.c()+"length: %#v", n)
 	if c.haveVers && vers != c.vers {
 		c.sendAlert(alertProtocolVersion)
 		return c.in.setErrorLocked(fmt.Errorf("tls: received record with version %x when expecting version %x", vers, c.vers))
@@ -580,6 +655,10 @@ Again:
 			return c.in.setErrorLocked(fmt.Errorf("tls: first record does not look like a TLS handshake"))
 		}
 	}
+
+	// 少なくとも record header 分は読んだが、その body までは読めてるとは限ら無い
+	// そこで、 recordHeaderLen + n(length) 分あらためて読み込む。
+	// もし、すでに読まれていれば、何もせず戻ってくる
 	if err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil {
 		if err == io.EOF {
 			err = io.ErrUnexpectedEOF
@@ -591,11 +670,17 @@ Again:
 	}
 
 	// Process message.
+	log.Println(i.c() + "Process message")
+
+	// block を一つのレコードと、残りに分ける
 	b, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)
+
+	log.Println(i.c() + "Decrypt")
 	ok, off, err := c.in.decrypt(b)
 	if !ok {
 		c.in.setErrorLocked(c.sendAlert(err))
 	}
+	log.Println(i.c()+"off:", off)
 	b.off = off
 	data := b.data[b.off:]
 	if len(data) > maxPlaintext {
@@ -647,6 +732,7 @@ Again:
 		b = nil
 
 	case recordTypeHandshake:
+		log.Println(i.c() + "process recordTypeHandshake")
 		// TODO(rsc): Should at least pick off connection close.
 		if typ != want {
 			return c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))
@@ -657,6 +743,7 @@ Again:
 	if b != nil {
 		c.in.freeBlock(b)
 	}
+
 	return c.in.err
 }
 
@@ -769,6 +856,9 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
 // the record layer.
 // c.in.Mutex < L; c.out.Mutex < L.
 func (c *Conn) readHandshake() (interface{}, error) {
+	log.Println(i.i() + ">conn.readHandshake()")
+	defer func() { log.Println(i.o() + "<conn.readHandshake()") }()
+
 	for c.hand.Len() < 4 {
 		if err := c.in.err; err != nil {
 			return nil, err
@@ -825,6 +915,7 @@ func (c *Conn) readHandshake() (interface{}, error) {
 	default:
 		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
 	}
+	log.Printf(i.c()+"hanshakeMessage: %T\n", m)
 
 	// The handshake message unmarshallers
 	// expect to be able to keep references to data,
@@ -881,6 +972,9 @@ func (c *Conn) Write(b []byte) (int, error) {
 // Read can be made to time out and return a net.Error with Timeout() == true
 // after a fixed time limit; see SetDeadline and SetReadDeadline.
 func (c *Conn) Read(b []byte) (n int, err error) {
+	log.Println(i.i() + ">conn.Read()")
+	defer func() { log.Println(i.o() + "<conn.Read()") }()
+
 	if err = c.Handshake(); err != nil {
 		return
 	}
@@ -961,6 +1055,9 @@ func (c *Conn) Close() error {
 // Most uses of this package need not call Handshake
 // explicitly: the first Read or Write will call it automatically.
 func (c *Conn) Handshake() error {
+	log.Println(i.i() + ">conn.Handshake()")
+	defer func() { log.Println(i.o() + "<conn.Handshake()") }()
+
 	c.handshakeMutex.Lock()
 	defer c.handshakeMutex.Unlock()
 	if err := c.handshakeErr; err != nil {
diff --git hs_messages.go hs_messages.go
index 799a776..2025f7c 100644
--- hs_messages.go
+++ hs_messages.go
@@ -4,7 +4,10 @@
 
 package tls
 
-import "bytes"
+import (
+	"bytes"
+	"log"
+)
 
 type clientHelloMsg struct {
 	raw                 []byte
@@ -290,6 +293,7 @@ func (m *clientHelloMsg) marshal() []byte {
 }
 
 func (m *clientHelloMsg) unmarshal(data []byte) bool {
+	log.Println(i.c(), "><clientHello.unmarshal()")
 	if len(data) < 42 {
 		return false
 	}
@@ -1025,6 +1029,7 @@ func (m *clientKeyExchangeMsg) equal(i interface{}) bool {
 }
 
 func (m *clientKeyExchangeMsg) marshal() []byte {
+	log.Println(i.c(), "><clientKeyExchangeMsg.marshal()")
 	if m.raw != nil {
 		return m.raw
 	}
@@ -1041,6 +1046,7 @@ func (m *clientKeyExchangeMsg) marshal() []byte {
 }
 
 func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
+	log.Println(i.c(), "><clientKeyExchangeMsg.unmarshal()")
 	m.raw = data
 	if len(data) < 4 {
 		return false
diff --git hs_server.go hs_server.go
index e16cddc..18c1d8e 100644
--- hs_server.go
+++ hs_server.go
@@ -14,6 +14,7 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 )
 
 // serverHandshakeState contains details of a server handshake in progress.
@@ -36,6 +37,9 @@ type serverHandshakeState struct {
 
 // serverHandshake performs a TLS handshake as a server.
 func (c *Conn) serverHandshake() error {
+	log.Println(i.i() + ">conn.serverHandshake()")
+	defer func() { log.Println(i.o() + "<conn.serverHandshake()") }()
+
 	config := c.config
 
 	// If this is the first server handshake, we generate a random key to
@@ -50,6 +54,7 @@ func (c *Conn) serverHandshake() error {
 		return err
 	}
 
+	log.Println(i.c(), "resume:", isResume)
 	// For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3
 	if isResume {
 		// The client has included a session ticket and so we do an abbreviated handshake.
@@ -80,15 +85,19 @@ func (c *Conn) serverHandshake() error {
 		if err := hs.doFullHandshake(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.establishKeys(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.readFinished(c.firstFinished[:]); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.sendSessionTicket(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.sendFinished(nil); err != nil {
 			return err
 		}
@@ -101,28 +110,39 @@ func (c *Conn) serverHandshake() error {
 // readClientHello reads a ClientHello message from the client and decides
 // whether we will perform session resumption.
 func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {
+	log.Println(i.i() + ">serverHandshakeState.readClientHello()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.readClientHello()") }()
+
 	config := hs.c.config
 	c := hs.c
 
+	// Handshake レコードを 1 つ読み込む
 	msg, err := c.readHandshake()
 	if err != nil {
 		return false, err
 	}
+	log.Printf(i.c()+"%T", msg)
+
 	var ok bool
+	// そもそも取得したのが ClientHello か
 	hs.clientHello, ok = msg.(*clientHelloMsg)
 	if !ok {
 		c.sendAlert(alertUnexpectedMessage)
 		return false, unexpectedMessageError(hs.clientHello, msg)
 	}
+	// tls のバージョンをチェック(小さすぎないか)
 	c.vers, ok = config.mutualVersion(hs.clientHello.vers)
 	if !ok {
 		c.sendAlert(alertProtocolVersion)
 		return false, fmt.Errorf("tls: client offered an unsupported, maximum protocol version of %x", hs.clientHello.vers)
 	}
+	// あとでの確認用
 	c.haveVers = true
 
+	// 返送用 ServerHello
 	hs.hello = new(serverHelloMsg)
 
+	// 送られてきた楕円曲線がサポートにあるかだけ調べる
 	supportedCurve := false
 	preferredCurves := config.curvePreferences()
 Curves:
@@ -135,6 +155,7 @@ Curves:
 		}
 	}
 
+	// point が 0 uint8 か調べる？
 	supportedPointFormat := false
 	for _, pointFormat := range hs.clientHello.supportedPoints {
 		if pointFormat == pointFormatUncompressed {
@@ -143,7 +164,9 @@ Curves:
 		}
 	}
 	hs.ellipticOk = supportedCurve && supportedPointFormat
+	log.Println(i.c()+"elliptickOk: ", hs.ellipticOk)
 
+	// null じゃなきゃだめ
 	foundCompression := false
 	// We only support null compression, so check that the client offered it.
 	for _, compression := range hs.clientHello.compressionMethods {
@@ -158,6 +181,7 @@ Curves:
 		return false, errors.New("tls: client does not support uncompressed connections")
 	}
 
+	// ServerHello を組み立てる
 	hs.hello.vers = c.vers
 	hs.hello.random = make([]byte, 32)
 	_, err = io.ReadFull(config.rand(), hs.hello.random)
@@ -167,10 +191,13 @@ Curves:
 	}
 	hs.hello.secureRenegotiation = hs.clientHello.secureRenegotiation
 	hs.hello.compressionMethod = compressionNone
+
+	// SNI
 	if len(hs.clientHello.serverName) > 0 {
 		c.serverName = hs.clientHello.serverName
 	}
 
+	// ALPN
 	if len(hs.clientHello.alpnProtocols) > 0 {
 		if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback {
 			hs.hello.alpnProtocol = selectedProto
@@ -187,12 +214,15 @@ Curves:
 		}
 	}
 
-	if hs.cert, err = config.getCertificate(&ClientHelloInfo{
+	// ClientHello の情報から Cert を選ぶ(SNI 考慮)
+	chi := &ClientHelloInfo{
 		CipherSuites:    hs.clientHello.cipherSuites,
 		ServerName:      hs.clientHello.serverName,
 		SupportedCurves: hs.clientHello.supportedCurves,
 		SupportedPoints: hs.clientHello.supportedPoints,
-	}); err != nil {
+	}
+	hs.cert, err = config.getCertificate(chi)
+	if err != nil {
 		c.sendAlert(alertInternalError)
 		return false, err
 	}
@@ -200,6 +230,10 @@ Curves:
 		hs.hello.scts = hs.cert.SignedCertificateTimestamps
 	}
 
+	// 上で選んだ cert をチェック
+
+	// Signer であり Public(), Sign() を持つか調べる
+	// publickey が ecdsa か rsa じゃないとだめ
 	if priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {
 		switch priv.Public().(type) {
 		case *ecdsa.PublicKey:
@@ -211,6 +245,10 @@ Curves:
 			return false, fmt.Errorf("crypto/tls: unsupported signing key type (%T)", priv.Public())
 		}
 	}
+	log.Println(i.c()+"hs.ecdsaOk, hs.rsaSignOk", hs.ecdsaOk, hs.rsaSignOk)
+
+	// Decrypter であり Public(), Decrypt() を持つか調べる
+	// rsa じゃないとだめ
 	if priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {
 		switch priv.Public().(type) {
 		case *rsa.PublicKey:
@@ -221,10 +259,13 @@ Curves:
 		}
 	}
 
+	// 再開できるか調べる
 	if hs.checkForResumption() {
 		return true, nil
 	}
 
+	// 自分が設定した cipher と client hello を比較
+	// PreferServerCipherSuites があれば server 優先
 	var preferenceList, supportedList []uint16
 	if c.config.PreferServerCipherSuites {
 		preferenceList = c.config.cipherSuites()
@@ -234,11 +275,14 @@ Curves:
 		supportedList = c.config.cipherSuites()
 	}
 
+	// CipherSuite を設定する
+	log.Println(i.i() + ">serverHandshakeState.setCipherSuite()")
 	for _, id := range preferenceList {
 		if hs.setCipherSuite(id, supportedList, c.vers) {
 			break
 		}
 	}
+	log.Println(i.o() + "<serverHandshakeState.setCipherSuite()")
 
 	if hs.suite == nil {
 		c.sendAlert(alertHandshakeFailure)
@@ -262,6 +306,9 @@ Curves:
 
 // checkForResumption reports whether we should perform resumption on this connection.
 func (hs *serverHandshakeState) checkForResumption() bool {
+	log.Println(i.i() + ">serverHandshakeState.checkForResumption()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.checkForResumption()") }()
+
 	c := hs.c
 
 	if c.config.SessionTicketsDisabled {
@@ -336,9 +383,13 @@ func (hs *serverHandshakeState) doResumeHandshake() error {
 }
 
 func (hs *serverHandshakeState) doFullHandshake() error {
-	config := hs.c.config
+	log.Println(i.i() + ">doFullHandshake()")
+	defer func() { log.Println(i.o() + "<doFullHandshake()") }()
+
+	config := hs.c.config // config 内に cert, cipher がある
 	c := hs.c
 
+	// OCSP チェック
 	if hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {
 		hs.hello.ocspStapling = true
 	}
@@ -346,20 +397,31 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 	hs.hello.ticketSupported = hs.clientHello.ticketSupported && !config.SessionTicketsDisabled
 	hs.hello.cipherSuite = hs.suite.id
 
+	// Finished で送る hash を準備する
+	// hash 関数は中で PRF とかに決まる
 	hs.finishedHash = newFinishedHash(hs.c.vers, hs.suite)
 	if config.ClientAuth == NoClientCert {
 		// No need to keep a full record of the handshake if client
 		// certificates won't be used.
 		hs.finishedHash.discardHandshakeBuffer()
 	}
+
+	// new したときに選んだ hash に書き込む
+	// これが finished になる
 	hs.finishedHash.Write(hs.clientHello.marshal())
 	hs.finishedHash.Write(hs.hello.marshal())
+
+	// server hello を送信
 	c.writeRecord(recordTypeHandshake, hs.hello.marshal())
+	log.Println(i.c(), "wirte hello")
 
+	// certificate を送信
 	certMsg := new(certificateMsg)
 	certMsg.certificates = hs.cert.Certificate
+	// これも finished の hash に書き込む
 	hs.finishedHash.Write(certMsg.marshal())
 	c.writeRecord(recordTypeHandshake, certMsg.marshal())
+	log.Println(i.c(), "write cert")
 
 	if hs.hello.ocspStapling {
 		certStatus := new(certificateStatusMsg)
@@ -367,19 +429,27 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		certStatus.response = hs.cert.OCSPStaple
 		hs.finishedHash.Write(certStatus.marshal())
 		c.writeRecord(recordTypeHandshake, certStatus.marshal())
+		log.Println(i.c(), "write cert status")
 	}
 
 	keyAgreement := hs.suite.ka(c.vers)
+	log.Printf(i.c()+" keyAgreement: %#T", keyAgreement)
+
+	// RSA の場合 ServerKeyExchange は無い
 	skx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)
 	if err != nil {
 		c.sendAlert(alertHandshakeFailure)
+		log.Println(i.c(), "write alert")
 		return err
 	}
 	if skx != nil {
+		// やっぱり finished に書く
 		hs.finishedHash.Write(skx.marshal())
 		c.writeRecord(recordTypeHandshake, skx.marshal())
+		log.Println(i.c(), "write server key exchange")
 	}
 
+	// client 認証をする場合
 	if config.ClientAuth >= RequestClientCert {
 		// Request a client certificate
 		certReq := new(certificateRequestMsg)
@@ -402,27 +472,36 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		}
 		hs.finishedHash.Write(certReq.marshal())
 		c.writeRecord(recordTypeHandshake, certReq.marshal())
+		log.Println(i.c(), "write cert req")
 	}
 
+	// server hello done
 	helloDone := new(serverHelloDoneMsg)
+	// やっぱり finished に
 	hs.finishedHash.Write(helloDone.marshal())
 	c.writeRecord(recordTypeHandshake, helloDone.marshal())
+	log.Println(i.c(), "write hello done")
 
 	var pub crypto.PublicKey // public key for client auth, if any
 
+	// ClientKeyExchange 以降を受け取る
 	msg, err := c.readHandshake()
 	if err != nil {
 		return err
 	}
+	log.Printf(i.c()+"%T", msg)
 
 	var ok bool
+	// クライアント認証を要求していたら、これが返ってくる。
 	// If we requested a client certificate, then the client must send a
 	// certificate message, even if it's empty.
 	if config.ClientAuth >= RequestClientCert {
+		log.Println(i.c(), "request client cert")
 		if certMsg, ok = msg.(*certificateMsg); !ok {
 			c.sendAlert(alertUnexpectedMessage)
 			return unexpectedMessageError(certMsg, msg)
 		}
+		// 送られてきているなら finished に
 		hs.finishedHash.Write(certMsg.marshal())
 
 		if len(certMsg.certificates) == 0 {
@@ -434,6 +513,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			}
 		}
 
+		// クライアント認証を処理
 		pub, err = hs.processCertsFromClient(certMsg.certificates)
 		if err != nil {
 			return err
@@ -451,14 +531,23 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		c.sendAlert(alertUnexpectedMessage)
 		return unexpectedMessageError(ckx, msg)
 	}
+	log.Println(i.c(), "marshal client key exchange")
 	hs.finishedHash.Write(ckx.marshal())
 
+	// Client Key Exchange から Pre Master Secret を算出
+	// config.rand() は単なる crypto/rand
+	// hs.cert は hs.cert, err = config.getCertificate(chi) したやつ
+	// 実際は tls.Config に指定した Certificate が一つなので、それ
+	// ckx は今取得した奴
+	// c.vers はバージョン
 	preMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)
+	log.Println(i.c(), "preMasterSecret", preMasterSecret)
 	if err != nil {
 		c.sendAlert(alertHandshakeFailure)
 		return err
 	}
 	hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.clientHello.random, hs.hello.random)
+	log.Println(i.c(), "masterSecret", hs.masterSecret[:10])
 
 	// If we received a client cert in response to our certificate request message,
 	// the client will send us a certificateVerifyMsg immediately after the
@@ -466,8 +555,10 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 	// handshake-layer messages that is signed using the private key corresponding
 	// to the client's certificate. This allows us to verify that the client is in
 	// possession of the private key of the certificate.
+	log.Println(i.c(), "len(c.peerCertificates)", len(c.peerCertificates))
 	if len(c.peerCertificates) > 0 {
 		msg, err = c.readHandshake()
+		log.Println(msg)
 		if err != nil {
 			return err
 		}
@@ -476,6 +567,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			c.sendAlert(alertUnexpectedMessage)
 			return unexpectedMessageError(certVerify, msg)
 		}
+		log.Println(certVerify)
 
 		// Determine the signature type.
 		var signatureAndHash signatureAndHash
@@ -496,6 +588,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			}
 		}
 
+		log.Printf(i.c()+"%T", pub)
 		switch key := pub.(type) {
 		case *ecdsa.PublicKey:
 			if signatureAndHash.signature != signatureECDSA {
@@ -536,6 +629,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 
 		hs.finishedHash.Write(certVerify.marshal())
 	}
+	log.Println()
 
 	hs.finishedHash.discardHandshakeBuffer()
 
@@ -543,14 +637,24 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 }
 
 func (hs *serverHandshakeState) establishKeys() error {
+	log.Println(i.i() + ">serverHandshakeState.establishKeys()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.establishKeys()") }()
+
 	c := hs.c
 
 	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
 		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
+	log.Printf(i.c()+"clientMAC: %#v", clientMAC[:10])
+	log.Printf(i.c()+"serverMAC: %#v", serverMAC[:10])
+	log.Printf(i.c()+"clientKey: %#v", clientKey[:10])
+	log.Printf(i.c()+"serverKey: %#v", serverKey[:10])
+	log.Printf(i.c()+"clientIV : %#v", clientIV[:10])
+	log.Printf(i.c()+"serverIV : %#v", serverIV[:10])
 
 	var clientCipher, serverCipher interface{}
 	var clientHash, serverHash macFunction
 
+	log.Println(i.c()+"hs.suite.aead:", hs.suite.aead)
 	if hs.suite.aead == nil {
 		clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
 		clientHash = hs.suite.mac(c.vers, clientMAC)
@@ -568,6 +672,9 @@ func (hs *serverHandshakeState) establishKeys() error {
 }
 
 func (hs *serverHandshakeState) readFinished(out []byte) error {
+	log.Println(i.i() + ">serverHandshakeState.readFinished()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.readFinished()") }()
+
 	c := hs.c
 
 	c.readRecord(recordTypeChangeCipherSpec)
@@ -608,10 +715,14 @@ func (hs *serverHandshakeState) readFinished(out []byte) error {
 
 	hs.finishedHash.Write(clientFinished.marshal())
 	copy(out, verify)
+
 	return nil
 }
 
 func (hs *serverHandshakeState) sendSessionTicket() error {
+	log.Println(i.i() + ">serverHandshakeState.sendSessionTicket()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.sendSessionTicket()") }()
+
 	if !hs.hello.ticketSupported {
 		return nil
 	}
@@ -638,6 +749,9 @@ func (hs *serverHandshakeState) sendSessionTicket() error {
 }
 
 func (hs *serverHandshakeState) sendFinished(out []byte) error {
+	log.Println(i.i() + ">serverHandshakeState.sendFinished()")
+	defer func() { log.Println(i.o() + "<serverHandshakeState.sendFinished()") }()
+
 	c := hs.c
 
 	c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
diff --git key_agreement.go key_agreement.go
index 0e6a7c2..3f8ab60 100644
--- key_agreement.go
+++ key_agreement.go
@@ -15,6 +15,7 @@ import (
 	"encoding/asn1"
 	"errors"
 	"io"
+	"log"
 	"math/big"
 )
 
@@ -30,6 +31,9 @@ func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certif
 }
 
 func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {
+	log.Println(i.i(), ">rsaKeyAgreement.processClientKeyExchange()")
+	defer func() { log.Println(i.o(), "<rsaKeyAgreement.processClientKeyExchange()") }()
+
 	if len(ckx.ciphertext) < 2 {
 		return nil, errClientKeyExchange
 	}
@@ -43,6 +47,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certifi
 		ciphertext = ckx.ciphertext[2:]
 	}
 	priv, ok := cert.PrivateKey.(crypto.Decrypter)
+	log.Printf(i.c()+"%T", priv)
 	if !ok {
 		return nil, errors.New("tls: certificate private key does not implement crypto.Decrypter")
 	}
@@ -51,6 +56,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certifi
 	if err != nil {
 		return nil, err
 	}
+	log.Println(i.c(), "preMasterSecret", preMasterSecret[:10])
 	// We don't check the version number in the premaster secret.  For one,
 	// by checking it, we would leak information about the validity of the
 	// encrypted pre-master secret. Secondly, it provides only a small
@@ -278,25 +284,37 @@ NextCandidate:
 }
 
 func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {
+	log.Println(i.i(), ">ecdheKeyAgreement.processClientKeyExchange()")
+	defer func() { log.Println(i.o(), "<ecdheKeyAgreement.processClientKeyExchange()") }()
+
 	if len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	x, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])
 	if x == nil {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	if !ka.curve.IsOnCurve(x, y) {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	x, _ = ka.curve.ScalarMult(x, y, ka.privateKey)
+	log.Println()
 	preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)
+	log.Println()
 	xBytes := x.Bytes()
+	log.Println()
 	copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)
 
 	return preMasterSecret, nil
 }
 
 func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {
+	log.Println(i.i(), ">ecdheKeyAgreement.processServerKeyExchange()")
+	defer func() { log.Println(i.o(), "<ecdheKeyAgreement.processServerKeyExchange()") }()
+
 	if len(skx.key) < 4 {
 		return errServerKeyExchange
 	}
diff --git prf.go prf.go
index 6127c1c..ece6531 100644
--- prf.go
+++ prf.go
@@ -13,6 +13,7 @@ import (
 	"crypto/sha512"
 	"errors"
 	"hash"
+	"log"
 )
 
 // Split a premaster secret in two as specified in RFC 4346, section 5.
@@ -68,6 +69,7 @@ func prf10(result, secret, label, seed []byte) {
 
 // prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.
 func prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte) {
+	log.Println(i.c(), "PRF(pseudo-random function)")
 	return func(result, secret, label, seed []byte) {
 		labelAndSeed := make([]byte, len(label)+len(seed))
 		copy(labelAndSeed, label)
@@ -121,13 +123,19 @@ var keyExpansionLabel = []byte("key expansion")
 var clientFinishedLabel = []byte("client finished")
 var serverFinishedLabel = []byte("server finished")
 
+// 疑似乱数関数を選択
 func prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash) {
+	log.Println(i.c(), "prfAndHashForVersion")
 	switch version {
 	case VersionSSL30:
+		// SSL3 用
 		return prf30, crypto.Hash(0)
 	case VersionTLS10, VersionTLS11:
+		// TLS1 用
 		return prf10, crypto.Hash(0)
 	case VersionTLS12:
+		// TLS2 用
+		// SHA384 で切り分け
 		if suite.flags&suiteSHA384 != 0 {
 			return prf12(sha512.New384), crypto.SHA384
 		}
@@ -194,6 +202,10 @@ func lookupTLSHash(hash uint8) (crypto.Hash, error) {
 }
 
 func newFinishedHash(version uint16, cipherSuite *cipherSuite) finishedHash {
+	log.Println(i.i(), ">newFinishedHash")
+	log.Printf(i.c()+"version: %#v, suite: %#v", version, cipherSuite.id)
+	defer func() { log.Println(i.o(), "<newFinishedHash") }()
+
 	var buffer []byte
 	if version == VersionSSL30 || version >= VersionTLS12 {
 		buffer = []byte{}
