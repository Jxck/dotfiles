diff --git cipher_suites.go cipher_suites.go
index 869ffa5..39fa2d0 100644
--- cipher_suites.go
+++ cipher_suites.go
@@ -13,12 +13,19 @@ import (
 	"crypto/sha1"
 	"crypto/x509"
 	"hash"
+	"log"
 )
 
+func init() {
+	log.SetFlags(log.Lshortfile)
+}
+
+// keyAgreement の生成(generate) と処理(process)実装
 // a keyAgreement implements the client and server side of a TLS key agreement
 // protocol by generating and processing key exchange messages.
 type keyAgreement interface {
 	// On the server side, the first two methods are called in order.
+	// Server では、以下二つが順番に呼ばれる
 
 	// In the case that the key agreement protocol doesn't use a
 	// ServerKeyExchange message, generateServerKeyExchange can return nil,
@@ -27,6 +34,7 @@ type keyAgreement interface {
 	processClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)
 
 	// On the client side, the next two methods are called in order.
+	// Client では、以下二つが順番に呼ばれる
 
 	// This method may not be called if the server doesn't send a
 	// ServerKeyExchange message.
@@ -34,6 +42,7 @@ type keyAgreement interface {
 	generateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)
 }
 
+// 暗号スイートがそれぞれを含むかどうか
 const (
 	// suiteECDH indicates that the cipher suite involves elliptic curve
 	// Diffie-Hellman. This means that it should only be selected when the
@@ -56,6 +65,7 @@ const (
 	suiteDefaultOff
 )
 
+// key agreement と cipher, MAC 関数の組
 // A cipherSuite is a specific combination of key agreement, cipher and MAC
 // function. All cipher suites currently assume RSA key agreement.
 type cipherSuite struct {
@@ -147,7 +157,21 @@ func (f *fixedNonceAEAD) NonceSize() int { return 8 }
 func (f *fixedNonceAEAD) Overhead() int  { return f.aead.Overhead() }
 
 func (f *fixedNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {
+	log.Println(i.i(), ">fixedNonceAEAD.Seal")
+	defer func() { log.Println(i.o(), "<fixedNonceAEAD.Seal") }()
+
+	log.Println(i.c(), "sealNonce は aeadAESGCM で保存しておいた fixedNonce の値")
+	log.Printf(i.c()+" f.sealNonce %#v", f.sealNonce)
+
+	log.Println(i.c(), "f.sealNonce(fixedNonce=salt) の 4byte の後ろに、 nonce(explicitNonce) を 8byte つなげる")
 	copy(f.sealNonce[len(f.sealNonce)-8:], nonce)
+
+	log.Printf(i.c()+" out: %#v(%#v)", out, out[:cap(out)])
+	log.Printf(i.c()+" nonce: %#v(%#v)", f.sealNonce, f.sealNonce[:cap(f.sealNonce)])
+	log.Printf(i.c()+" plaintext: %#v(%#v)", plaintext, plaintext[:cap(plaintext)])
+	log.Printf(i.c()+" additionalData: %#v(%#v)", additionalData, additionalData[:cap(additionalData)])
+
+	log.Println(i.c(), "cipher.NewGCM(aes.NewCipher(key)) した cipher.AEAD の seal")
 	return f.aead.Seal(out, f.sealNonce, plaintext, additionalData)
 }
 
@@ -157,6 +181,13 @@ func (f *fixedNonceAEAD) Open(out, nonce, plaintext, additionalData []byte) ([]b
 }
 
 func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD {
+	log.Println(i.i(), ">aeadAESGCM")
+	defer func() { log.Println(i.o(), "<aeadAESGCM") }()
+
+	// key は clientWriteKey
+	log.Printf(i.c()+" key:= %#v", key)
+	log.Printf(i.c()+" fixedNonce:= %#v", fixedNonce)
+
 	aes, err := aes.NewCipher(key)
 	if err != nil {
 		panic(err)
@@ -166,8 +197,11 @@ func aeadAESGCM(key, fixedNonce []byte) cipher.AEAD {
 		panic(err)
 	}
 
+	log.Println(i.c(), "fixedNonce を sealNonce, openNonce として保存しておく")
 	nonce1, nonce2 := make([]byte, 12), make([]byte, 12)
+	// sealNonce
 	copy(nonce1, fixedNonce)
+	// openNonce
 	copy(nonce2, fixedNonce)
 
 	return &fixedNonceAEAD{nonce1, nonce2, aead}
diff --git common.go common.go
index c68ebfe..2a08ca3 100644
--- common.go
+++ common.go
@@ -13,6 +13,7 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 	"math/big"
 	"strings"
 	"sync"
@@ -474,6 +475,7 @@ func (c *Config) maxVersion() uint16 {
 	return c.MaxVersion
 }
 
+// secp256r1(23), secp384r1(24), secp521r1(25)
 var defaultCurvePreferences = []CurveID{CurveP256, CurveP384, CurveP521}
 
 func (c *Config) curvePreferences() []CurveID {
@@ -498,9 +500,19 @@ func (c *Config) mutualVersion(vers uint16) (uint16, bool) {
 	return vers, true
 }
 
+// ClientHello を元に最適な証明書を返す。が普通は一つなので最初のを返す。
 // getCertificate returns the best certificate for the given ClientHelloInfo,
 // defaulting to the first element of c.Certificates.
 func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error) {
+	log.Println(i.i(), ">Config.getCertificate()")
+	defer func() { log.Println(i.o(), "<Config.getCertificate()") }()
+
+	log.Printf(i.c()+" clientHello.CipherSuites %#v...%#v", clientHello.CipherSuites[:4], clientHello.CipherSuites[len(clientHello.CipherSuites)-4:])
+	log.Printf(i.c()+" clientHello.ServerName      %#v", clientHello.ServerName)
+	log.Printf(i.c()+" clientHello.SupportedCurves %#v", clientHello.SupportedCurves)
+	log.Printf(i.c()+" clientHello.SupportedPoints %#v", clientHello.SupportedPoints)
+
+	// SNI が有効だった場合
 	if c.GetCertificate != nil &&
 		(len(c.Certificates) == 0 || len(clientHello.ServerName) > 0) {
 		cert, err := c.GetCertificate(clientHello)
@@ -509,10 +521,12 @@ func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, err
 		}
 	}
 
+	// 証明書が無い場合
 	if len(c.Certificates) == 0 {
 		return nil, errors.New("crypto/tls: no certificates configured")
 	}
 
+	// 一個しかない
 	if len(c.Certificates) == 1 || c.NameToCertificate == nil {
 		// There's only one choice, so no point doing any work.
 		return &c.Certificates[0], nil
diff --git connection.go connection.go
index e3dcf15..938eaee 100644
--- connection.go
+++ connection.go
@@ -14,11 +14,46 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 	"net"
+	"strings"
 	"sync"
 	"time"
 )
 
+type Ind struct {
+	indent int
+}
+
+func (i *Ind) i() (str string) {
+	str = "\t" + strings.Repeat(" ", i.indent)
+	i.indent = i.indent + 2
+	return
+}
+
+func (i *Ind) c() string {
+	return "\t" + strings.Repeat(" ", i.indent)
+}
+
+func (i *Ind) o() (str string) {
+	i.indent = i.indent - 2
+	str = "\t" + strings.Repeat(" ", i.indent)
+	return
+}
+
+var i = new(Ind)
+
+var S = map[recordType]string{
+	0x14: "CHANGE_CIPHER_SPEC",
+	0x15: "ALERT",
+	0x16: "HANDSHAKE",
+	0x17: "APPLICATION_DATA",
+}
+
+func init() {
+	log.SetFlags(log.Lshortfile)
+}
+
 // A Conn represents a secured connection.
 // It implements the net.Conn interface.
 type Conn struct {
@@ -127,6 +162,10 @@ func (hc *halfConn) error() error {
 // prepareCipherSpec sets the encryption and MAC states
 // that a subsequent changeCipherSpec will use.
 func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) {
+	log.Println(i.i(), ">halfConn.prepareCipherSpec")
+	defer func() { log.Println(i.o(), "<halfConn.prepareCipherSpec") }()
+
+	log.Println("ここで nextCipher など予約しておく")
 	hc.version = version
 	hc.nextCipher = cipher
 	hc.nextMac = mac
@@ -135,9 +174,15 @@ func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac ma
 // changeCipherSpec changes the encryption and MAC states
 // to the ones previously passed to prepareCipherSpec.
 func (hc *halfConn) changeCipherSpec() error {
+	log.Println(i.i(), ">halfConn.changeCipherSpec")
+	defer func() { log.Println(i.o(), "<halfConn.changeCipherSpec") }()
+
 	if hc.nextCipher == nil {
 		return alertInternalError
 	}
+
+	// ここで nextCipher に予約しておいた chiper が
+	// hc.cipher に置き換わる。
 	hc.cipher = hc.nextCipher
 	hc.mac = hc.nextMac
 	hc.nextCipher = nil
@@ -238,23 +283,32 @@ type cbcMode interface {
 // success boolean, the number of bytes to skip from the start of the record in
 // order to get the application payload, and an optional alert value.
 func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert) {
+	log.Println(i.i(), ">halfConn.decrypt()")
+	defer func() { log.Println(i.o(), "<halfConn.decrypt()") }()
+
+	// レコードから body だけ取り出す
 	// pull out payload
 	payload := b.data[recordHeaderLen:]
 
 	macSize := 0
 	if hc.mac != nil {
+		log.Println(i.c(), "hc has mac")
 		macSize = hc.mac.Size()
 	}
 
 	paddingGood := byte(255)
 	explicitIVLen := 0
 
+	// cipher があったら複合化
 	// decrypt
 	if hc.cipher != nil {
+		log.Printf(i.c()+" hc has cipher %T", hc.cipher)
 		switch c := hc.cipher.(type) {
 		case cipher.Stream:
+			log.Println(i.c(), "cipher.Stream")
 			c.XORKeyStream(payload, payload)
 		case cipher.AEAD:
+			log.Println(i.c(), "cipher.AEAD")
 			explicitIVLen = 8
 			if len(payload) < explicitIVLen {
 				return false, 0, alertBadRecordMAC
@@ -269,12 +323,17 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)
 			additionalData[11] = byte(n >> 8)
 			additionalData[12] = byte(n)
 			var err error
+
+			log.Printf(i.c()+" before: %#v", payload)
 			payload, err = c.Open(payload[:0], nonce, payload, additionalData[:])
 			if err != nil {
 				return false, 0, alertBadRecordMAC
 			}
+			log.Printf(i.c()+" after: %#v", payload)
+
 			b.resize(recordHeaderLen + explicitIVLen + len(payload))
 		case cbcMode:
+			log.Println(i.c(), "cbcMode")
 			blockSize := c.BlockSize()
 			if hc.version >= VersionTLS11 {
 				explicitIVLen = blockSize
@@ -313,6 +372,7 @@ func (hc *halfConn) decrypt(b *block) (ok bool, prefixLen int, alertValue alert)
 
 	// check, strip mac
 	if hc.mac != nil {
+		log.Printf(i.c()+" hc has mac %v", hc.mac)
 		if len(payload) < macSize {
 			return false, 0, alertBadRecordMAC
 		}
@@ -354,7 +414,14 @@ func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {
 
 // encrypt encrypts and macs the data in b.
 func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {
+	log.Println(i.i(), ">encrypt")
+	defer func() { log.Println(i.o(), "<encrypt") }()
+
+	log.Printf(i.c()+" [%v(%v)]b.data : %#v", len(b.data), cap(b.data), b.data[:cap(b.data)])
+	log.Printf(i.c()+" explicitIVLen := %#v", explicitIVLen)
+
 	// mac
+	log.Println(i.c(), "mac:", hc.mac)
 	if hc.mac != nil {
 		mac := hc.mac.MAC(hc.outDigestBuf, hc.seq[0:], b.data[:recordHeaderLen], b.data[recordHeaderLen+explicitIVLen:])
 
@@ -364,27 +431,76 @@ func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {
 		hc.outDigestBuf = mac
 	}
 
-	payload := b.data[recordHeaderLen:]
+	//CAUTION: ここの Payload [24]byte と
+	payload := b.data[recordHeaderLen:] // recordHeaderLen = 5
+	log.Printf(i.c()+" payload: %#v", payload)
 
 	// encrypt
+	// hc.prepareCipherSpec() で準備された hc.nextCipher が
+	// hs.changeCipherSpec() を呼んで hs.cipher に置き換わるまで
+	// ここは素通り
+	log.Printf(i.c()+" cipher: %T", hc.cipher)
 	if hc.cipher != nil {
 		switch c := hc.cipher.(type) {
 		case cipher.Stream:
 			c.XORKeyStream(payload, payload)
 		case cipher.AEAD:
+			log.Println("いよいよこれを cipher.AEAD で暗号化する")
+			log.Printf(i.c()+" [type, ver, len, explicitIV, marshalled data](%v) = %#v", len(b.data), b.data)
+
+			log.Println(i.c(), "nonce と payload を切り出す")
+
 			payloadLen := len(b.data) - recordHeaderLen - explicitIVLen
-			b.resize(len(b.data) + c.Overhead())
+			log.Printf(i.c()+" payloadLen(%v) := len(b.data)(%v) - recordHeaderLen(%v) - explicitIVLen(%v)", payloadLen, len(b.data), recordHeaderLen, explicitIVLen)
+
+			log.Printf(i.c()+" b.resize(len(b.data)(%v) + c.Overhead(%v)", len(b.data), c.Overhead())
+
+			log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data[:cap(b.data)])
+			log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
+			b.resize(len(b.data) + c.Overhead()) // ここでバッファを拡張している
+			log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data[:cap(b.data)])
+			log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
+
+			//// !!!!!!!!!!!!!!!!!!!!!!!!!!!!
+			log.Println("!!!!!!!!!!!!!!!!!!!!!!!!!!!! 試しにゼロクリア")
+			zero := make([]byte, 16)
+			copy(b.data[29:], zero)
+			//// !!!!!!!!!!!!!!!!!!!!!!!!!!!!
+
+			log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
+
 			nonce := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
+			log.Printf(i.c()+"nonce   := b.data[recordHeaderLen(%v) : recordHeaderLen+explicitIVLen(%v)] = %#v", recordHeaderLen, explicitIVLen, nonce)
+
+			//CAUTION: ここの Payload は別物!!
 			payload := b.data[recordHeaderLen+explicitIVLen:]
+			log.Printf(i.c()+"payload := b.data[recordHeaderLen(%v)+explicitIVLen(%v):] = %#v", recordHeaderLen, explicitIVLen, payload)
+
 			payload = payload[:payloadLen]
+			log.Printf(i.c()+"payload = payload[:payloadLen(%v)] = %#v", payloadLen, payload)
 
+			log.Println(i.c(), "additional_data = write_seq + header")
 			var additionalData [13]byte
 			copy(additionalData[:], hc.seq[:])
 			copy(additionalData[8:], b.data[:3])
 			additionalData[11] = byte(payloadLen >> 8)
 			additionalData[12] = byte(payloadLen)
 
+			log.Printf(i.c()+" additionalData := %#v", additionalData)
+
+			log.Println(i.c(), "これらを Seal する")
+			log.Printf(i.c()+" - nonce: %#v", nonce)
+			log.Printf(i.c()+" - payload: %#v", payload) // 16byte
+			log.Printf(i.c()+" - additional: %#v", additionalData)
+
+			log.Printf(i.c()+" b.data: %#v", b.data) // header+explicit+payload(16)+buffer(16)
+
+			// 先頭 32byte のみ暗号化されていた
+			// ゼロクリアしたバッファを渡しても 16byte のインプットに対して
+			// 32byte 暗号化されていた
+			log.Printf(i.c()+" payload: %#v", payload[:cap(payload)]) // 16byte の slice だが下の+16byte 含め 32byte 暗号化される
 			c.Seal(payload[:0], nonce, payload, additionalData[:])
+			log.Printf(i.c()+" payload: %#v", payload[:cap(payload)]) // payload の後ろ含め 32byte が暗号化される
 		case cbcMode:
 			blockSize := c.BlockSize()
 			if explicitIVLen > 0 {
@@ -400,10 +516,18 @@ func (hc *halfConn) encrypt(b *block, explicitIVLen int) (bool, alert) {
 		}
 	}
 
+	log.Printf(i.c()+" b.data(%v): %#v", len(b.data), b.data)
+	log.Printf(i.c()+" payload(%v): %#v", len(payload), payload)
+
 	// update length to include MAC and any block padding needed.
 	n := len(b.data) - recordHeaderLen
+	log.Println(i.c(), "暗号化したデータのヘッダ以外の長さが", n)
+	log.Println(i.c(), "暗号化前の長さは", b.data[3:5], "だったので更新")
 	b.data[3] = byte(n >> 8)
 	b.data[4] = byte(n)
+
+	log.Printf(i.c()+" 結果出来上がったデータ %#v", b.data)
+
 	hc.incSeq()
 
 	return true, 0
@@ -444,17 +568,28 @@ func (b *block) reserve(n int) {
 // readFromUntil reads from r into b until b contains at least n bytes
 // or else returns an error.
 func (b *block) readFromUntil(r io.Reader, n int) error {
+	log.Printf(i.i()+" >block.readFromUntil(r, n=%v), len(b.data)=%v cap(b.data)=%v", n, len(b.data), cap(b.data))
+	defer func() { log.Printf(i.o() + " <block.readFromUntil") }()
+
 	// quick case
+	// n byte 読みたいところすでに読まれてる
 	if len(b.data) >= n {
 		return nil
 	}
 
 	// read until have enough.
+	// b.data がバッファでそこに cap を確保する
 	b.reserve(n)
 	for {
+		// conn.Read()
+		// 確保したバッファのデータ末尾から cap までの間に
+		// 読めるだけ read() する。
 		m, err := r.Read(b.data[len(b.data):cap(b.data)])
+		log.Printf(i.c()+" %v byte read", m)
+		// len が更新されて無いので、読んだ分で更新
 		b.data = b.data[0 : len(b.data)+m]
 		if len(b.data) >= n {
+			log.Println(i.c(), "len(b.data) >= n", len(b.data), n)
 			// TODO(bradfitz,agl): slightly suspicious
 			// that we're throwing away r.Read's err here.
 			break
@@ -511,6 +646,9 @@ func (hc *halfConn) splitBlock(b *block, n int) (*block, *block) {
 // and updates the record layer state.
 // c.in.Mutex <= L; c.input == nil.
 func (c *Conn) readRecord(want recordType) error {
+	log.Println(i.i(), ">conn.readRecord()", S[want])
+	defer func() { log.Println(i.o(), "<conn.readRecord()", want) }()
+
 	// Caller must be in sync with connection:
 	// handshake data if handshake not yet completed,
 	// else application data.  (We don't support renegotiation.)
@@ -537,6 +675,7 @@ Again:
 	b := c.rawInput
 
 	// Read header, payload.
+	// d.data に少なくとも record header 分は読み込む
 	if err := b.readFromUntil(c.conn, recordHeaderLen); err != nil {
 		// RFC suggests that EOF without an alertCloseNotify is
 		// an error, but popular web sites seem to do this,
@@ -550,6 +689,7 @@ Again:
 		return err
 	}
 	typ := recordType(b.data[0])
+	log.Printf(i.c()+" typ: %#v", S[typ])
 
 	// No valid TLS record has a type of 0x80, however SSLv2 handshakes
 	// start with a uint16 length where the MSB is set and the first record
@@ -561,7 +701,10 @@ Again:
 	}
 
 	vers := uint16(b.data[1])<<8 | uint16(b.data[2])
+	log.Printf(i.c()+" vers: %#v", vers)
+
 	n := int(b.data[3])<<8 | int(b.data[4])
+	log.Printf(i.c()+" length: %#v", n)
 	if c.haveVers && vers != c.vers {
 		c.sendAlert(alertProtocolVersion)
 		return c.in.setErrorLocked(fmt.Errorf("tls: received record with version %x when expecting version %x", vers, c.vers))
@@ -580,6 +723,10 @@ Again:
 			return c.in.setErrorLocked(fmt.Errorf("tls: first record does not look like a TLS handshake"))
 		}
 	}
+
+	// 少なくとも record header 分は読んだが、その body までは読めてるとは限ら無い
+	// そこで、 recordHeaderLen + n(length) 分あらためて読み込む。
+	// もし、すでに読まれていれば、何もせず戻ってくる
 	if err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil {
 		if err == io.EOF {
 			err = io.ErrUnexpectedEOF
@@ -591,11 +738,17 @@ Again:
 	}
 
 	// Process message.
+	log.Println(i.c(), "Process message")
+
+	// block を一つのレコードと、残りに分ける
 	b, c.rawInput = c.in.splitBlock(b, recordHeaderLen+n)
+
+	log.Println(i.c(), "Decrypt")
 	ok, off, err := c.in.decrypt(b)
 	if !ok {
 		c.in.setErrorLocked(c.sendAlert(err))
 	}
+	log.Println(i.c(), "off:", off)
 	b.off = off
 	data := b.data[b.off:]
 	if len(data) > maxPlaintext {
@@ -647,6 +800,7 @@ Again:
 		b = nil
 
 	case recordTypeHandshake:
+		log.Println(i.c(), "process recordTypeHandshake")
 		// TODO(rsc): Should at least pick off connection close.
 		if typ != want {
 			return c.in.setErrorLocked(c.sendAlert(alertNoRenegotiation))
@@ -657,6 +811,7 @@ Again:
 	if b != nil {
 		c.in.freeBlock(b)
 	}
+
 	return c.in.err
 }
 
@@ -690,10 +845,20 @@ func (c *Conn) sendAlert(err alert) error {
 // to the connection and updates the record layer state.
 // c.out.Mutex <= L.
 func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
+	log.Println(i.i(), ">writeRecord", typ)
+	defer func() { log.Println(i.o(), "<writeRecord") }()
+
+	log.Printf(i.c()+" [%v(%v)]data: %#v", len(data), cap(data), data[:cap(data)])
+
+	// changeCipherSpec を送るまでは暗号化せず
+	// 送ったタイミングで暗号化をする
+
 	b := c.out.newBlock()
+	log.Printf(i.c()+" [%v(%v)]b.data: %#v", len(b.data), cap(b.data), b.data[:cap(b.data)])
 	for len(data) > 0 {
 		m := len(data)
 		if m > maxPlaintext {
+			log.Println("m > maxPlaintext")
 			m = maxPlaintext
 		}
 		explicitIVLen := 0
@@ -703,6 +868,7 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
 		if c.out.version >= VersionTLS11 {
 			var ok bool
 			if cbc, ok = c.out.cipher.(cbcMode); ok {
+				log.Println(cbc, ok)
 				explicitIVLen = cbc.BlockSize()
 			}
 		}
@@ -716,9 +882,18 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
 				// nonce. Therefore we use the sequence number
 				// as the nonce.
 				explicitIVIsSeq = true
+				log.Println(i.c(), "nonce が 8byte で短いから sequence num を使うらしい?")
 			}
 		}
+
+		log.Println(i.c(), "explicitIVLen", explicitIVLen)
+		log.Println(i.c(), "explicitIVIsSeq", explicitIVIsSeq)
+
+		log.Println(i.c(), "recordHeaderLen + explicitIVLen + len(data) =", recordHeaderLen+explicitIVLen+m)
+
 		b.resize(recordHeaderLen + explicitIVLen + m)
+		log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
+
 		b.data[0] = byte(typ)
 		vers := c.vers
 		if vers == 0 {
@@ -730,18 +905,36 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
 		b.data[2] = byte(vers)
 		b.data[3] = byte(m >> 8)
 		b.data[4] = byte(m)
+
+		log.Printf(i.c()+" type=%#v, vers=%#v, len(data)=%#v を書き込む", typ, vers, m)
+		log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
+
 		if explicitIVLen > 0 {
+			// b.data の中にある領域を、参照だけ取り出す
 			explicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
 			if explicitIVIsSeq {
+				log.Println(i.c(), "clientIV に sequence", c.out.seq, "を使う")
 				copy(explicitIV, c.out.seq[:])
 			} else {
+				log.Println(i.c(), "clientIV に random を使う")
 				if _, err = io.ReadFull(c.config.rand(), explicitIV); err != nil {
 					break
 				}
 			}
+			log.Printf(i.c()+" explicitIV:= %#v", explicitIV)
 		}
+		log.Printf(i.c()+" b.data[recordHeaderLen(%v):] の後ろに explicitIV を入れるのでこうなる", recordHeaderLen)
+		log.Printf(i.c()+" %#v", b.data[:recordHeaderLen+explicitIVLen])
+
+		log.Printf(i.c()+" その後ろにdata = %#v をくっつける", data)
 		copy(b.data[recordHeaderLen+explicitIVLen:], data)
+		log.Printf(i.c()+" [type, ver, len, explicitIV, marshalled data](%v) = %#v", len(b.data), b.data)
+
+		// encrypt 内は hc.cipher が設定されるまでは暗号化がおこらない
+		// 上で b の特定領域に乱数を入れたので、 IVLen を渡すとそれが取り出せる。
 		c.out.encrypt(b, explicitIVLen)
+
+		log.Printf(i.c()+" [%v]b.data: %#v", len(b.data), b.data)
 		_, err = c.conn.Write(b.data)
 		if err != nil {
 			break
@@ -769,6 +962,9 @@ func (c *Conn) writeRecord(typ recordType, data []byte) (n int, err error) {
 // the record layer.
 // c.in.Mutex < L; c.out.Mutex < L.
 func (c *Conn) readHandshake() (interface{}, error) {
+	log.Println(i.i(), ">conn.readHandshake()")
+	defer func() { log.Println(i.o(), "<conn.readHandshake()") }()
+
 	for c.hand.Len() < 4 {
 		if err := c.in.err; err != nil {
 			return nil, err
@@ -825,6 +1021,7 @@ func (c *Conn) readHandshake() (interface{}, error) {
 	default:
 		return nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))
 	}
+	log.Printf(i.c()+" handshakeMessage: %T\n", m)
 
 	// The handshake message unmarshallers
 	// expect to be able to keep references to data,
@@ -881,6 +1078,9 @@ func (c *Conn) Write(b []byte) (int, error) {
 // Read can be made to time out and return a net.Error with Timeout() == true
 // after a fixed time limit; see SetDeadline and SetReadDeadline.
 func (c *Conn) Read(b []byte) (n int, err error) {
+	log.Println(i.i(), ">conn.Read()")
+	defer func() { log.Println(i.o(), "<conn.Read()") }()
+
 	if err = c.Handshake(); err != nil {
 		return
 	}
@@ -961,6 +1161,9 @@ func (c *Conn) Close() error {
 // Most uses of this package need not call Handshake
 // explicitly: the first Read or Write will call it automatically.
 func (c *Conn) Handshake() error {
+	log.Println(i.i(), ">conn.Handshake()")
+	defer func() { log.Println(i.o(), "<conn.Handshake()") }()
+
 	c.handshakeMutex.Lock()
 	defer c.handshakeMutex.Unlock()
 	if err := c.handshakeErr; err != nil {
diff --git hs_client.go hs_client.go
index 0b591d7..21091cf 100644
--- hs_client.go
+++ hs_client.go
@@ -14,10 +14,15 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 	"net"
 	"strconv"
 )
 
+func init() {
+	log.SetFlags(log.Lshortfile)
+}
+
 type clientHandshakeState struct {
 	c            *Conn
 	serverHello  *serverHelloMsg
@@ -29,6 +34,9 @@ type clientHandshakeState struct {
 }
 
 func (c *Conn) clientHandshake() error {
+	log.Println(i.i(), ">c.clientHandshake()")
+	defer func() { log.Println(i.o(), "<c.clientHandshake()") }()
+
 	if c.config == nil {
 		c.config = defaultConfig()
 	}
@@ -139,6 +147,7 @@ NextCipherSuite:
 
 	c.writeRecord(recordTypeHandshake, hello.marshal())
 
+	log.Println()
 	msg, err := c.readHandshake()
 	if err != nil {
 		return err
@@ -148,6 +157,7 @@ NextCipherSuite:
 		c.sendAlert(alertUnexpectedMessage)
 		return unexpectedMessageError(serverHello, msg)
 	}
+	log.Println()
 
 	vers, ok := c.config.mutualVersion(serverHello.vers)
 	if !ok || vers < VersionTLS10 {
@@ -164,6 +174,7 @@ NextCipherSuite:
 		return fmt.Errorf("tls: server selected an unsupported cipher suite")
 	}
 
+	log.Println()
 	hs := &clientHandshakeState{
 		c:            c,
 		serverHello:  serverHello,
@@ -173,6 +184,7 @@ NextCipherSuite:
 		session:      session,
 	}
 
+	log.Println()
 	isResume, err := hs.processServerHello()
 	if err != nil {
 		return err
@@ -186,9 +198,11 @@ NextCipherSuite:
 		hs.finishedHash.discardHandshakeBuffer()
 	}
 
+	log.Println()
 	hs.finishedHash.Write(hs.hello.marshal())
 	hs.finishedHash.Write(hs.serverHello.marshal())
 
+	log.Println(isResume)
 	if isResume {
 		if err := hs.establishKeys(); err != nil {
 			return err
@@ -206,12 +220,15 @@ NextCipherSuite:
 		if err := hs.doFullHandshake(); err != nil {
 			return err
 		}
+		log.Println("=====================ここから establishKeys() =====================")
 		if err := hs.establishKeys(); err != nil {
 			return err
 		}
+		log.Println("=====================ここから sendFinished() =====================")
 		if err := hs.sendFinished(c.firstFinished[:]); err != nil {
 			return err
 		}
+		log.Println("=====================ここまで sendFinished() =====================")
 		if err := hs.readSessionTicket(); err != nil {
 			return err
 		}
@@ -220,10 +237,12 @@ NextCipherSuite:
 		}
 	}
 
+	log.Println()
 	if sessionCache != nil && hs.session != nil && session != hs.session {
 		sessionCache.Put(cacheKey, hs.session)
 	}
 
+	log.Println()
 	c.didResume = isResume
 	c.handshakeComplete = true
 	c.cipherSuite = suite.id
@@ -231,6 +250,9 @@ NextCipherSuite:
 }
 
 func (hs *clientHandshakeState) doFullHandshake() error {
+	log.Println(i.i(), ">doFullHandshake")
+	defer func() { log.Println(i.o(), "<doFullHandshake") }()
+
 	c := hs.c
 
 	msg, err := c.readHandshake()
@@ -481,22 +503,33 @@ func (hs *clientHandshakeState) doFullHandshake() error {
 }
 
 func (hs *clientHandshakeState) establishKeys() error {
+	log.Println(i.i(), ">establishKeys")
+	defer func() { log.Println(i.o(), "<establishKeys") }()
+
+	log.Println("ここで master secret を分解し key, iv を生成する")
+
 	c := hs.c
 
 	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
 		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
 	var clientCipher, serverCipher interface{}
 	var clientHash, serverHash macFunction
+
 	if hs.suite.cipher != nil {
 		clientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)
 		clientHash = hs.suite.mac(c.vers, clientMAC)
 		serverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)
 		serverHash = hs.suite.mac(c.vers, serverMAC)
 	} else {
+		log.Println("ここで呼ぶのは cipherSuites に設定された aeadAESGCM")
+		log.Println("client, server で二回呼ぶ")
 		clientCipher = hs.suite.aead(clientKey, clientIV)
 		serverCipher = hs.suite.aead(serverKey, serverIV)
 	}
 
+	// ここで hs.nextCipher に予約をしておく
+	// hs.changeCipherSpec が呼ばれたら
+	// それ以降暗号化が始まる。
 	c.in.prepareCipherSpec(c.vers, serverCipher, serverHash)
 	c.out.prepareCipherSpec(c.vers, clientCipher, clientHash)
 	return nil
@@ -612,8 +645,12 @@ func (hs *clientHandshakeState) readSessionTicket() error {
 }
 
 func (hs *clientHandshakeState) sendFinished(out []byte) error {
+	log.Println(i.i(), ">sendFinished")
+	defer func() { log.Println(i.c(), "<sendFinished") }()
+
 	c := hs.c
 
+	log.Println(i.c(), "ChangeCipherSpec を送る")
 	c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
 	if hs.serverHello.nextProtoNeg {
 		nextProto := new(nextProtoMsg)
@@ -627,8 +664,18 @@ func (hs *clientHandshakeState) sendFinished(out []byte) error {
 	}
 
 	finished := new(finishedMsg)
+	log.Println(i.c(), "ここまでのフレームの Hash を計算し、 PRF にかける")
 	finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)
+
+	log.Printf(i.c()+" finished.verifyData: %#v", finished.verifyData)
+	log.Printf(i.c()+" finished.marshal(): %#v", finished.marshal())
+
+	log.Println(i.c(), "hash を載せた finished 自体も hash に加える")
 	hs.finishedHash.Write(finished.marshal())
+
+	log.Println(i.c(), "この finished フレームを暗号化して送る")
+	log.Println(i.c(), "送る finished フレームの長さ", len(finished.marshal()))
+
 	c.writeRecord(recordTypeHandshake, finished.marshal())
 	copy(out, finished.verifyData)
 	return nil
diff --git hs_messages.go hs_messages.go
index 799a776..377ca8e 100644
--- hs_messages.go
+++ hs_messages.go
@@ -4,7 +4,10 @@
 
 package tls
 
-import "bytes"
+import (
+	"bytes"
+	"log"
+)
 
 type clientHelloMsg struct {
 	raw                 []byte
@@ -290,6 +293,7 @@ func (m *clientHelloMsg) marshal() []byte {
 }
 
 func (m *clientHelloMsg) unmarshal(data []byte) bool {
+	log.Println(i.c(), "><clientHello.unmarshal()")
 	if len(data) < 42 {
 		return false
 	}
@@ -1025,6 +1029,7 @@ func (m *clientKeyExchangeMsg) equal(i interface{}) bool {
 }
 
 func (m *clientKeyExchangeMsg) marshal() []byte {
+	log.Println(i.c(), "><clientKeyExchangeMsg.marshal()")
 	if m.raw != nil {
 		return m.raw
 	}
@@ -1041,6 +1046,7 @@ func (m *clientKeyExchangeMsg) marshal() []byte {
 }
 
 func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {
+	log.Println(i.c(), "><clientKeyExchangeMsg.unmarshal()")
 	m.raw = data
 	if len(data) < 4 {
 		return false
@@ -1069,6 +1075,9 @@ func (m *finishedMsg) equal(i interface{}) bool {
 }
 
 func (m *finishedMsg) marshal() (x []byte) {
+	log.Println(i.i(), ">finished.marshal()")
+	defer func() { log.Println(i.o(), ">finished.marshal()") }()
+
 	if m.raw != nil {
 		return m.raw
 	}
@@ -1078,6 +1087,10 @@ func (m *finishedMsg) marshal() (x []byte) {
 	x[3] = byte(len(m.verifyData))
 	copy(x[4:], m.verifyData)
 	m.raw = x
+
+	log.Printf(i.c()+" type: %#v", x[0])
+	log.Printf(i.c()+" len: %#v", x[3])
+	log.Printf(i.c()+" verifyData: %#v", x[4:])
 	return
 }
 
diff --git hs_server.go hs_server.go
index e16cddc..ca1670e 100644
--- hs_server.go
+++ hs_server.go
@@ -14,6 +14,7 @@ import (
 	"errors"
 	"fmt"
 	"io"
+	"log"
 )
 
 // serverHandshakeState contains details of a server handshake in progress.
@@ -36,6 +37,9 @@ type serverHandshakeState struct {
 
 // serverHandshake performs a TLS handshake as a server.
 func (c *Conn) serverHandshake() error {
+	log.Println(i.i(), ">conn.serverHandshake()")
+	defer func() { log.Println(i.o(), "<conn.serverHandshake()") }()
+
 	config := c.config
 
 	// If this is the first server handshake, we generate a random key to
@@ -50,6 +54,7 @@ func (c *Conn) serverHandshake() error {
 		return err
 	}
 
+	log.Println(i.c(), "resume:", isResume)
 	// For an overview of TLS handshaking, see https://tools.ietf.org/html/rfc5246#section-7.3
 	if isResume {
 		// The client has included a session ticket and so we do an abbreviated handshake.
@@ -80,15 +85,19 @@ func (c *Conn) serverHandshake() error {
 		if err := hs.doFullHandshake(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.establishKeys(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.readFinished(c.firstFinished[:]); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.sendSessionTicket(); err != nil {
 			return err
 		}
+		log.Println()
 		if err := hs.sendFinished(nil); err != nil {
 			return err
 		}
@@ -101,28 +110,39 @@ func (c *Conn) serverHandshake() error {
 // readClientHello reads a ClientHello message from the client and decides
 // whether we will perform session resumption.
 func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {
+	log.Println(i.i(), ">serverHandshakeState.readClientHello()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.readClientHello()") }()
+
 	config := hs.c.config
 	c := hs.c
 
+	// Handshake レコードを 1 つ読み込む
 	msg, err := c.readHandshake()
 	if err != nil {
 		return false, err
 	}
+	log.Printf(i.c()+" %T", msg)
+
 	var ok bool
+	// そもそも取得したのが ClientHello か
 	hs.clientHello, ok = msg.(*clientHelloMsg)
 	if !ok {
 		c.sendAlert(alertUnexpectedMessage)
 		return false, unexpectedMessageError(hs.clientHello, msg)
 	}
+	// tls のバージョンをチェック(小さすぎないか)
 	c.vers, ok = config.mutualVersion(hs.clientHello.vers)
 	if !ok {
 		c.sendAlert(alertProtocolVersion)
 		return false, fmt.Errorf("tls: client offered an unsupported, maximum protocol version of %x", hs.clientHello.vers)
 	}
+	// あとでの確認用
 	c.haveVers = true
 
+	// 返送用 ServerHello
 	hs.hello = new(serverHelloMsg)
 
+	// 送られてきた楕円曲線がサポートにあるかだけ調べる
 	supportedCurve := false
 	preferredCurves := config.curvePreferences()
 Curves:
@@ -135,6 +155,7 @@ Curves:
 		}
 	}
 
+	// point が 0 uint8 か調べる？
 	supportedPointFormat := false
 	for _, pointFormat := range hs.clientHello.supportedPoints {
 		if pointFormat == pointFormatUncompressed {
@@ -143,7 +164,9 @@ Curves:
 		}
 	}
 	hs.ellipticOk = supportedCurve && supportedPointFormat
+	log.Println(i.c(), "elliptickOk: ", hs.ellipticOk)
 
+	// null じゃなきゃだめ
 	foundCompression := false
 	// We only support null compression, so check that the client offered it.
 	for _, compression := range hs.clientHello.compressionMethods {
@@ -158,6 +181,7 @@ Curves:
 		return false, errors.New("tls: client does not support uncompressed connections")
 	}
 
+	// ServerHello を組み立てる
 	hs.hello.vers = c.vers
 	hs.hello.random = make([]byte, 32)
 	_, err = io.ReadFull(config.rand(), hs.hello.random)
@@ -167,10 +191,13 @@ Curves:
 	}
 	hs.hello.secureRenegotiation = hs.clientHello.secureRenegotiation
 	hs.hello.compressionMethod = compressionNone
+
+	// SNI
 	if len(hs.clientHello.serverName) > 0 {
 		c.serverName = hs.clientHello.serverName
 	}
 
+	// ALPN
 	if len(hs.clientHello.alpnProtocols) > 0 {
 		if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback {
 			hs.hello.alpnProtocol = selectedProto
@@ -187,12 +214,15 @@ Curves:
 		}
 	}
 
-	if hs.cert, err = config.getCertificate(&ClientHelloInfo{
+	// ClientHello の情報から Cert を選ぶ(SNI 考慮)
+	chi := &ClientHelloInfo{
 		CipherSuites:    hs.clientHello.cipherSuites,
 		ServerName:      hs.clientHello.serverName,
 		SupportedCurves: hs.clientHello.supportedCurves,
 		SupportedPoints: hs.clientHello.supportedPoints,
-	}); err != nil {
+	}
+	hs.cert, err = config.getCertificate(chi)
+	if err != nil {
 		c.sendAlert(alertInternalError)
 		return false, err
 	}
@@ -200,6 +230,10 @@ Curves:
 		hs.hello.scts = hs.cert.SignedCertificateTimestamps
 	}
 
+	// 上で選んだ cert をチェック
+
+	// Signer であり Public(), Sign() を持つか調べる
+	// publickey が ecdsa か rsa じゃないとだめ
 	if priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {
 		switch priv.Public().(type) {
 		case *ecdsa.PublicKey:
@@ -211,6 +245,10 @@ Curves:
 			return false, fmt.Errorf("crypto/tls: unsupported signing key type (%T)", priv.Public())
 		}
 	}
+	log.Println(i.c(), "hs.ecdsaOk, hs.rsaSignOk", hs.ecdsaOk, hs.rsaSignOk)
+
+	// Decrypter であり Public(), Decrypt() を持つか調べる
+	// rsa じゃないとだめ
 	if priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {
 		switch priv.Public().(type) {
 		case *rsa.PublicKey:
@@ -221,10 +259,13 @@ Curves:
 		}
 	}
 
+	// 再開できるか調べる
 	if hs.checkForResumption() {
 		return true, nil
 	}
 
+	// 自分が設定した cipher と client hello を比較
+	// PreferServerCipherSuites があれば server 優先
 	var preferenceList, supportedList []uint16
 	if c.config.PreferServerCipherSuites {
 		preferenceList = c.config.cipherSuites()
@@ -234,11 +275,14 @@ Curves:
 		supportedList = c.config.cipherSuites()
 	}
 
+	// CipherSuite を設定する
+	log.Println(i.i(), ">serverHandshakeState.setCipherSuite()")
 	for _, id := range preferenceList {
 		if hs.setCipherSuite(id, supportedList, c.vers) {
 			break
 		}
 	}
+	log.Println(i.o(), "<serverHandshakeState.setCipherSuite()")
 
 	if hs.suite == nil {
 		c.sendAlert(alertHandshakeFailure)
@@ -262,6 +306,9 @@ Curves:
 
 // checkForResumption reports whether we should perform resumption on this connection.
 func (hs *serverHandshakeState) checkForResumption() bool {
+	log.Println(i.i(), ">serverHandshakeState.checkForResumption()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.checkForResumption()") }()
+
 	c := hs.c
 
 	if c.config.SessionTicketsDisabled {
@@ -336,9 +383,13 @@ func (hs *serverHandshakeState) doResumeHandshake() error {
 }
 
 func (hs *serverHandshakeState) doFullHandshake() error {
-	config := hs.c.config
+	log.Println(i.i(), ">doFullHandshake()")
+	defer func() { log.Println(i.o(), "<doFullHandshake()") }()
+
+	config := hs.c.config // config 内に cert, cipher がある
 	c := hs.c
 
+	// OCSP チェック
 	if hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {
 		hs.hello.ocspStapling = true
 	}
@@ -346,20 +397,31 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 	hs.hello.ticketSupported = hs.clientHello.ticketSupported && !config.SessionTicketsDisabled
 	hs.hello.cipherSuite = hs.suite.id
 
+	// Finished で送る hash を準備する
+	// hash 関数は中で PRF とかに決まる
 	hs.finishedHash = newFinishedHash(hs.c.vers, hs.suite)
 	if config.ClientAuth == NoClientCert {
 		// No need to keep a full record of the handshake if client
 		// certificates won't be used.
 		hs.finishedHash.discardHandshakeBuffer()
 	}
+
+	// new したときに選んだ hash に書き込む
+	// これが finished になる
 	hs.finishedHash.Write(hs.clientHello.marshal())
 	hs.finishedHash.Write(hs.hello.marshal())
+
+	// server hello を送信
 	c.writeRecord(recordTypeHandshake, hs.hello.marshal())
+	log.Println(i.c(), "wirte hello")
 
+	// certificate を送信
 	certMsg := new(certificateMsg)
 	certMsg.certificates = hs.cert.Certificate
+	// これも finished の hash に書き込む
 	hs.finishedHash.Write(certMsg.marshal())
 	c.writeRecord(recordTypeHandshake, certMsg.marshal())
+	log.Println(i.c(), "write cert")
 
 	if hs.hello.ocspStapling {
 		certStatus := new(certificateStatusMsg)
@@ -367,19 +429,27 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		certStatus.response = hs.cert.OCSPStaple
 		hs.finishedHash.Write(certStatus.marshal())
 		c.writeRecord(recordTypeHandshake, certStatus.marshal())
+		log.Println(i.c(), "write cert status")
 	}
 
 	keyAgreement := hs.suite.ka(c.vers)
+	log.Printf(i.c()+" keyAgreement: %#T", keyAgreement)
+
+	// RSA の場合 ServerKeyExchange は無い
 	skx, err := keyAgreement.generateServerKeyExchange(config, hs.cert, hs.clientHello, hs.hello)
 	if err != nil {
 		c.sendAlert(alertHandshakeFailure)
+		log.Println(i.c(), "write alert")
 		return err
 	}
 	if skx != nil {
+		// やっぱり finished に書く
 		hs.finishedHash.Write(skx.marshal())
 		c.writeRecord(recordTypeHandshake, skx.marshal())
+		log.Println(i.c(), "write server key exchange")
 	}
 
+	// client 認証をする場合
 	if config.ClientAuth >= RequestClientCert {
 		// Request a client certificate
 		certReq := new(certificateRequestMsg)
@@ -402,27 +472,36 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		}
 		hs.finishedHash.Write(certReq.marshal())
 		c.writeRecord(recordTypeHandshake, certReq.marshal())
+		log.Println(i.c(), "write cert req")
 	}
 
+	// server hello done
 	helloDone := new(serverHelloDoneMsg)
+	// やっぱり finished に
 	hs.finishedHash.Write(helloDone.marshal())
 	c.writeRecord(recordTypeHandshake, helloDone.marshal())
+	log.Println(i.c(), "write hello done")
 
 	var pub crypto.PublicKey // public key for client auth, if any
 
+	// ClientKeyExchange 以降を受け取る
 	msg, err := c.readHandshake()
 	if err != nil {
 		return err
 	}
+	log.Printf(i.c()+" %T", msg)
 
 	var ok bool
+	// クライアント認証を要求していたら、これが返ってくる。
 	// If we requested a client certificate, then the client must send a
 	// certificate message, even if it's empty.
 	if config.ClientAuth >= RequestClientCert {
+		log.Println(i.c(), "request client cert")
 		if certMsg, ok = msg.(*certificateMsg); !ok {
 			c.sendAlert(alertUnexpectedMessage)
 			return unexpectedMessageError(certMsg, msg)
 		}
+		// 送られてきているなら finished に
 		hs.finishedHash.Write(certMsg.marshal())
 
 		if len(certMsg.certificates) == 0 {
@@ -434,6 +513,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			}
 		}
 
+		// クライアント認証を処理
 		pub, err = hs.processCertsFromClient(certMsg.certificates)
 		if err != nil {
 			return err
@@ -451,14 +531,23 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 		c.sendAlert(alertUnexpectedMessage)
 		return unexpectedMessageError(ckx, msg)
 	}
+	log.Println(i.c(), "marshal client key exchange")
 	hs.finishedHash.Write(ckx.marshal())
 
+	// Client Key Exchange から Pre Master Secret を算出
+	// config.rand() は単なる crypto/rand
+	// hs.cert は hs.cert, err = config.getCertificate(chi) したやつ
+	// 実際は tls.Config に指定した Certificate が一つなので、それ
+	// ckx は今取得した奴
+	// c.vers はバージョン
 	preMasterSecret, err := keyAgreement.processClientKeyExchange(config, hs.cert, ckx, c.vers)
+	log.Println(i.c(), "preMasterSecret", preMasterSecret)
 	if err != nil {
 		c.sendAlert(alertHandshakeFailure)
 		return err
 	}
 	hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.clientHello.random, hs.hello.random)
+	log.Println(i.c(), "masterSecret", hs.masterSecret[:10])
 
 	// If we received a client cert in response to our certificate request message,
 	// the client will send us a certificateVerifyMsg immediately after the
@@ -466,8 +555,10 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 	// handshake-layer messages that is signed using the private key corresponding
 	// to the client's certificate. This allows us to verify that the client is in
 	// possession of the private key of the certificate.
+	log.Println(i.c(), "len(c.peerCertificates)", len(c.peerCertificates))
 	if len(c.peerCertificates) > 0 {
 		msg, err = c.readHandshake()
+		log.Println(msg)
 		if err != nil {
 			return err
 		}
@@ -476,6 +567,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			c.sendAlert(alertUnexpectedMessage)
 			return unexpectedMessageError(certVerify, msg)
 		}
+		log.Println(certVerify)
 
 		// Determine the signature type.
 		var signatureAndHash signatureAndHash
@@ -496,6 +588,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 			}
 		}
 
+		log.Printf(i.c()+" %T", pub)
 		switch key := pub.(type) {
 		case *ecdsa.PublicKey:
 			if signatureAndHash.signature != signatureECDSA {
@@ -536,6 +629,7 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 
 		hs.finishedHash.Write(certVerify.marshal())
 	}
+	log.Println()
 
 	hs.finishedHash.discardHandshakeBuffer()
 
@@ -543,14 +637,24 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 }
 
 func (hs *serverHandshakeState) establishKeys() error {
+	log.Println(i.i(), ">serverHandshakeState.establishKeys()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.establishKeys()") }()
+
 	c := hs.c
 
 	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
 		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
+	log.Printf(i.c()+" clientMAC: %#v", clientMAC[:10])
+	log.Printf(i.c()+" serverMAC: %#v", serverMAC[:10])
+	log.Printf(i.c()+" clientKey: %#v", clientKey[:10])
+	log.Printf(i.c()+" serverKey: %#v", serverKey[:10])
+	log.Printf(i.c()+" clientIV : %#v", clientIV[:10])
+	log.Printf(i.c()+" serverIV : %#v", serverIV[:10])
 
 	var clientCipher, serverCipher interface{}
 	var clientHash, serverHash macFunction
 
+	log.Println(i.c(), "hs.suite.aead:", hs.suite.aead)
 	if hs.suite.aead == nil {
 		clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
 		clientHash = hs.suite.mac(c.vers, clientMAC)
@@ -568,6 +672,9 @@ func (hs *serverHandshakeState) establishKeys() error {
 }
 
 func (hs *serverHandshakeState) readFinished(out []byte) error {
+	log.Println(i.i(), ">serverHandshakeState.readFinished()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.readFinished()") }()
+
 	c := hs.c
 
 	c.readRecord(recordTypeChangeCipherSpec)
@@ -608,10 +715,14 @@ func (hs *serverHandshakeState) readFinished(out []byte) error {
 
 	hs.finishedHash.Write(clientFinished.marshal())
 	copy(out, verify)
+
 	return nil
 }
 
 func (hs *serverHandshakeState) sendSessionTicket() error {
+	log.Println(i.i(), ">serverHandshakeState.sendSessionTicket()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.sendSessionTicket()") }()
+
 	if !hs.hello.ticketSupported {
 		return nil
 	}
@@ -638,6 +749,9 @@ func (hs *serverHandshakeState) sendSessionTicket() error {
 }
 
 func (hs *serverHandshakeState) sendFinished(out []byte) error {
+	log.Println(i.i(), ">serverHandshakeState.sendFinished()")
+	defer func() { log.Println(i.o(), "<serverHandshakeState.sendFinished()") }()
+
 	c := hs.c
 
 	c.writeRecord(recordTypeChangeCipherSpec, []byte{1})
diff --git key_agreement.go key_agreement.go
index 0e6a7c2..70ec332 100644
--- key_agreement.go
+++ key_agreement.go
@@ -15,6 +15,7 @@ import (
 	"encoding/asn1"
 	"errors"
 	"io"
+	"log"
 	"math/big"
 )
 
@@ -30,6 +31,9 @@ func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certif
 }
 
 func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {
+	log.Println(i.i(), ">rsaKeyAgreement.processClientKeyExchange()")
+	defer func() { log.Println(i.o(), "<rsaKeyAgreement.processClientKeyExchange()") }()
+
 	if len(ckx.ciphertext) < 2 {
 		return nil, errClientKeyExchange
 	}
@@ -43,6 +47,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certifi
 		ciphertext = ckx.ciphertext[2:]
 	}
 	priv, ok := cert.PrivateKey.(crypto.Decrypter)
+	log.Printf(i.c()+" %T", priv)
 	if !ok {
 		return nil, errors.New("tls: certificate private key does not implement crypto.Decrypter")
 	}
@@ -51,6 +56,7 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certifi
 	if err != nil {
 		return nil, err
 	}
+	log.Println(i.c(), "preMasterSecret", preMasterSecret[:10])
 	// We don't check the version number in the premaster secret.  For one,
 	// by checking it, we would leak information about the validity of the
 	// encrypted pre-master secret. Secondly, it provides only a small
@@ -65,6 +71,9 @@ func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *
 }
 
 func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {
+	log.Println(i.i(), ">rsaKeyAgreement.generateClientKeyExchange()")
+	defer func() { log.Println(i.o(), "<rsaKeyAgreement.generateClientKeyExchange()") }()
+
 	preMasterSecret := make([]byte, 48)
 	preMasterSecret[0] = byte(clientHello.vers >> 8)
 	preMasterSecret[1] = byte(clientHello.vers)
@@ -278,25 +287,37 @@ NextCandidate:
 }
 
 func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {
+	log.Println(i.i(), ">ecdheKeyAgreement.processClientKeyExchange()")
+	defer func() { log.Println(i.o(), "<ecdheKeyAgreement.processClientKeyExchange()") }()
+
 	if len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	x, y := elliptic.Unmarshal(ka.curve, ckx.ciphertext[1:])
 	if x == nil {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	if !ka.curve.IsOnCurve(x, y) {
 		return nil, errClientKeyExchange
 	}
+	log.Println()
 	x, _ = ka.curve.ScalarMult(x, y, ka.privateKey)
+	log.Println()
 	preMasterSecret := make([]byte, (ka.curve.Params().BitSize+7)>>3)
+	log.Println()
 	xBytes := x.Bytes()
+	log.Println()
 	copy(preMasterSecret[len(preMasterSecret)-len(xBytes):], xBytes)
 
 	return preMasterSecret, nil
 }
 
 func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {
+	log.Println(i.i(), ">ecdheKeyAgreement.processServerKeyExchange()")
+	defer func() { log.Println(i.o(), "<ecdheKeyAgreement.processServerKeyExchange()") }()
+
 	if len(skx.key) < 4 {
 		return errServerKeyExchange
 	}
diff --git prf.go prf.go
index 747b817..48f8666 100644
--- prf.go
+++ prf.go
@@ -13,6 +13,7 @@ import (
 	"crypto/sha512"
 	"errors"
 	"hash"
+	"log"
 )
 
 // Split a premaster secret in two as specified in RFC 4346, section 5.
@@ -24,6 +25,12 @@ func splitPreMasterSecret(secret []byte) (s1, s2 []byte) {
 
 // pHash implements the P_hash function, as defined in RFC 4346, section 5.
 func pHash(result, secret, seed []byte, hash func() hash.Hash) {
+	log.Println(i.i(), ">pHash()")
+	defer func() { log.Println(i.o(), "<pHash()") }()
+	log.Printf(i.c()+" result: %#v", result)
+	log.Printf(i.c()+" secret: %#v", secret)
+	log.Printf(i.c()+" seed: %#v", seed)
+
 	h := hmac.New(hash, secret)
 	h.Write(seed)
 	a := h.Sum(nil)
@@ -68,7 +75,15 @@ func prf10(result, secret, label, seed []byte) {
 
 // prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.
 func prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte) {
+	log.Println(i.c(), ">prf12() 関数を返す")
 	return func(result, secret, label, seed []byte) {
+		log.Println(i.i(), ">prf()")
+		defer func() { log.Println(i.o(), "<prf12()") }()
+		log.Printf(i.c()+" result: %#v", result)
+		log.Printf(i.c()+" secret: %#v", secret)
+		log.Printf(i.c()+" label: %#v", label)
+		log.Printf(i.c()+" seed: %#v", seed)
+
 		labelAndSeed := make([]byte, len(label)+len(seed))
 		copy(labelAndSeed, label)
 		copy(labelAndSeed[len(label):], seed)
@@ -121,16 +136,25 @@ var keyExpansionLabel = []byte("key expansion")
 var clientFinishedLabel = []byte("client finished")
 var serverFinishedLabel = []byte("server finished")
 
+// 疑似乱数関数を選択
 func prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash) {
+	log.Println(i.c(), "prfAndHashForVersion")
+	log.Printf(i.c()+" suite: %#v", suite.id)
 	switch version {
 	case VersionSSL30:
+		// SSL3 用
 		return prf30, crypto.Hash(0)
 	case VersionTLS10, VersionTLS11:
+		// TLS1 用
 		return prf10, crypto.Hash(0)
 	case VersionTLS12:
+		// TLS2 用
+		// SHA384 で切り分け
 		if suite.flags&suiteSHA384 != 0 {
+			log.Println(i.c(), "TLS12, sha512")
 			return prf12(sha512.New384), crypto.SHA384
 		}
+		log.Println(i.c(), "TLS12, sha256")
 		return prf12(sha256.New), crypto.SHA256
 	default:
 		panic("unknown version")
@@ -145,12 +169,21 @@ func prfForVersion(version uint16, suite *cipherSuite) func(result, secret, labe
 // masterFromPreMasterSecret generates the master secret from the pre-master
 // secret. See http://tools.ietf.org/html/rfc5246#section-8.1
 func masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) []byte {
+	log.Println(i.i(), ">masterFromPreMasterSecret")
+	defer func() { log.Println(i.o(), "<masterFromPreMasterSecret") }()
+
+	log.Printf(i.c()+" clientRandom: %#v", clientRandom)
+	log.Printf(i.c()+" serverRandom: %#v", serverRandom)
+	log.Printf(i.c()+" preMasterSecret: %#v", preMasterSecret)
+
 	seed := make([]byte, 0, len(clientRandom)+len(serverRandom))
 	seed = append(seed, clientRandom...)
 	seed = append(seed, serverRandom...)
 
 	masterSecret := make([]byte, masterSecretLength)
 	prfForVersion(version, suite)(masterSecret, preMasterSecret, masterSecretLabel, seed)
+
+	log.Println(i.c(), "masterSecret:", masterSecret)
 	return masterSecret
 }
 
@@ -158,10 +191,25 @@ func masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecr
 // secret, given the lengths of the MAC key, cipher key and IV, as defined in
 // RFC 2246, section 6.3.
 func keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {
+	log.Println(i.i(), ">keysFromMasterSecret")
+	defer func() { log.Println(i.o(), "<keysFromMasterSecret") }()
+
+	log.Println(i.c(), "生成材料")
+	log.Printf(i.c()+" clientRandom:= %#v", clientRandom)
+	log.Printf(i.c()+" serverRandom:= %#v", serverRandom)
+	log.Printf(i.c()+" masterSecret:= %#v", masterSecret)
+
+	log.Println(i.c(), "長さ")
+	log.Printf(i.c()+" macLen:= %#v", macLen)
+	log.Printf(i.c()+" keyLen:= %#v", keyLen)
+	log.Printf(i.c()+" ivLen:= %#v", ivLen)
+
 	seed := make([]byte, 0, len(serverRandom)+len(clientRandom))
 	seed = append(seed, serverRandom...)
 	seed = append(seed, clientRandom...)
 
+	log.Printf(i.c()+" seed:= %#v", seed)
+
 	n := 2*macLen + 2*keyLen + 2*ivLen
 	keyMaterial := make([]byte, n)
 	prfForVersion(version, suite)(keyMaterial, masterSecret, keyExpansionLabel, seed)
@@ -176,6 +224,15 @@ func keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clie
 	clientIV = keyMaterial[:ivLen]
 	keyMaterial = keyMaterial[ivLen:]
 	serverIV = keyMaterial[:ivLen]
+
+	log.Println(i.c(), "生成結果")
+	log.Printf(i.c()+" clientMAC:= %#v", clientMAC)
+	log.Printf(i.c()+" serverMAC:= %#v", serverMAC)
+	log.Printf(i.c()+" clientKey:= %#v", clientKey)
+	log.Printf(i.c()+" serverKey:= %#v", serverKey)
+	log.Printf(i.c()+" clientIV := %#v", clientIV)
+	log.Printf(i.c()+" serverIV := %#v", serverIV)
+
 	return
 }
 
@@ -195,6 +252,10 @@ func lookupTLSHash(hash uint8) (crypto.Hash, error) {
 }
 
 func newFinishedHash(version uint16, cipherSuite *cipherSuite) finishedHash {
+	log.Println(i.i(), ">newFinishedHash")
+	log.Printf(i.c()+" version: %#v, suite: %#v", version, cipherSuite.id)
+	defer func() { log.Println(i.o(), "<newFinishedHash") }()
+
 	var buffer []byte
 	if version == VersionSSL30 || version >= VersionTLS12 {
 		buffer = []byte{}
@@ -226,6 +287,9 @@ type finishedHash struct {
 }
 
 func (h *finishedHash) Write(msg []byte) (n int, err error) {
+	log.Println(i.i(), ">finishedHash.Write()")
+	defer func() { log.Println(i.o(), "<finishedHash.Write()") }()
+
 	h.client.Write(msg)
 	h.server.Write(msg)
 
@@ -289,11 +353,17 @@ var ssl3ServerFinishedMagic = [4]byte{0x53, 0x52, 0x56, 0x52}
 // clientSum returns the contents of the verify_data member of a client's
 // Finished message.
 func (h finishedHash) clientSum(masterSecret []byte) []byte {
+	log.Println(i.i(), ">finishedHash.clientSum()")
+	defer func() { log.Println(i.o(), "<finishedHash.clientSum()") }()
+
 	if h.version == VersionSSL30 {
 		return finishedSum30(h.clientMD5, h.client, masterSecret, ssl3ClientFinishedMagic[:])
 	}
 
 	out := make([]byte, finishedVerifyLength)
+	log.Printf(i.c()+" masterSecret: %#v", masterSecret)
+	log.Printf(i.c()+" h.Sum(): %#v", h.Sum())
+	log.Println(i.c(), "これらと 'client finished' を prf() にかける")
 	h.prf(out, masterSecret, clientFinishedLabel, h.Sum())
 	return out
 }
